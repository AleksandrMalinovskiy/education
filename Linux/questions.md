## Linux.

1. Что такое LA? В каких единицах измеряется?
<details>
  <summary>Ответ</summary>
  LA (load average) -- параметр, определяющий среднюю нагрузку на систему за период времени (1 мин, 5 минут, 15 минут). Изменяется в количестве задач на одно ядро процессора. На нагрузку системы также влияет количество задач ввода-вывода и задержка сети. Также влияние на расчета LA оказывает: 1. Технология Hyper-Threading, которая делит одно физическое ядро на 2 логических, 2. Технология Turbo Bust, которая позволяет разгонять тактовую частоту процессора и работать на частоте выше заявленной, т.е. выше номинальной частоты (время на обработку одной задачи уменьшается). 
</details>

2. Что будет если на сервере LA = 100? 
<details>
  <summary>Ответ</summary>
  Вероятно, что на сервере будет наблюдаться замедленная работа сервисов, но если параметр LA равен количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной.
</details>

3. Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?
<details>
  <summary>Ответ</summary>

  На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр *wa* в утилите *top*) в дисков и задержка сети. Данные параметры могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему. 

</details>

4. Представлен вывод команды *top*. Что означает каждая запись в выводе?
   ```
   top - 21:29:24 up 14:18,  1 user,  load average: 0,78, 1,48,   1,10
   Tasks: 277 total,   3 running, 274 sleeping,   0 stopped,      0 zombie
   %Cpu(s): 12,4 us,  2,5 sy,  0,1 ni, 84,8 id,  0,1 wa,  0,0   hi,  0,1 si,  0,0 st
   KiB Mem :  7106404 total,   306972 free,  3127144 used,    3672288 buff/cache
   KiB Swap:  8191996 total,  8191996 free,        0 used.    3270520 avail Mem 
   ```

<details>
  <summary>Ответ</summary>

*top* - название утилиты.

*21:29:24* - текущее время системы.

*up 14:18* - сколько часов:минут система работает с момента последнего запуска.

*1 user* - количество пользователей авторизованных в системе.

*load average: 0,78, 1,48, 1,10* - параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут.

*277 total* - всего процессов в системе.

*3 running* - количество процессов в работе.

*274 sleeping* - количество процессов в состоянии sleeping: ожидает какого-либо события или сигнала.

*0 stopped* - количество приостановленных процессов сигналом STOP или выполнением трассировки.

*0 zombie* - количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения.

| Параметр | Описание |
|-------------------------------|------------------------------------------------------------------------------------------------|
| us (user) | Использование процессора пользовательским процессами |
| sy (system) | Использование процессора системным процессами |
| ni (nice) | Использование процессора процессами с измененным приоритетом с помощью команды nice |
| id (idle) | Простой процессора. Можно сказать, что это свободные ресурсы |
| wa (IO-wait) | Говорит о простое, связанным с вводом/выводом |
| hi (hardware interrupts) | Показывает сколько процессорного времени было потрачено на обслуживание аппаратного прерывания |
| si (software interrupts) | Показывает сколько процессорного времени было потрачено на обслуживание софтверного прерывания |
| st (stolen by the hypervisor) | Показывает сколько процессорного времени было «украдено» гипервизором |

KiB Mem - количество оперативной памяти в кибибайтах (кратно 1024):
*7106404 total* -- всего доступно оперативной памяти в системе,
*306972 free* -- свободно оперативной памяти для использования,
*3127144 used* -- использовано оперативной памяти,
*3672288 buff/cache* -- буферизовано/закешировано оперативной памяти.

*KiB Swap* - количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске:
*8191996 total* - всего выделено swap-памяти,
*8191996 free* - свободно swap-памяти
*0 used* - использовано swap-памяти,
*3270520 avail Mem* - доступно для использования swap-памяти.

</details>

5. Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?

<details>
  <summary>Ответ</summary>

  В утилите top нажать `1`, чтобы отобразить все ядра в системе.

</details>

6. Как в утилите top в Linux посмотреть какой командой был запущен процесс?

<details>
  <summary>Ответ</summary>

  В утилите top нажать `c`, чтобы отобразить команды, которыми были запущены процессы.

</details>

6. Как происходит HTTPS соединение?

<details>
  <summary>Ответ</summary>

Когда вы вводите адрес сайта в браузере, он спрашивает у сервера, установлен ли для сайта сертификат. В ответ сервер отправляет общую информацию об SSL-сертификате и публичный ключ, то есть сам сертификат. Браузер сверяет информацию со списком авторизованных центров сертификации. Если всё в порядке, браузер генерирует сеансовый ключ, зашифровывает его публичным ключом и отправляет на сервер. Сервер расшифровывает сообщение и сохраняет сеансовый ключ. После этого между браузером и сайтом устанавливается безопасное соединение через протокол HTTPS.

![https-process](imgs/https.png)

</details>

7. Чем отличается TCP от UDP? Что лучше?

<details>
  <summary>Ответ</summary>

TCP – транспортный протокол передачи данных в сетях TCP/IP, предназначен для управления передачей данных интернета. Пакеты в TCP называются сегментами.
Ориентирован на соединение, используется для передачи данных (электронная почта, файлы, сообщения). При определении потери пакетов будет выполнен перезапрос потерянных пакетов.

UDP – транспортный протокол, передающий сообщения-датаграммы без необходимости установки соединения в IP-сети. Не ориентирован на установление соединения, используется в потоковой передаче данных (IPTV, VoIP). При потере пакетов перезапроса потерянных пакетов не происходит.

Нельзя сказать, что TCP лучше UDP, т.к. данные транспортные протоколы используются для различных типов передачи трафика.

</details>

8. Как происходит соединение TCP?

<details>
  <summary>Ответ</summary>

![TCP_Handshake](imgs/tcp-connection.png)

1. Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом SYN.
Дальнейший алгоритм:
Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет (буферы и управляющие структуры памяти) для обслуживания нового клиента;
В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED;
​В случае неудачи сервер посылает клиенту сегмент с флагом RST.
2. Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK.
Дальнейший алгоритм:
Если он одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED;
Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться;
Если клиент не получает ответа в течение 10 секунд, то он повторяет процесс соединения заново.

3. Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED.
В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED.
Процесс называется «трёхэтапным рукопожатием» (англ. three way handshake), так как несмотря на то что возможен процесс установления соединения с использованием четырёх сегментов (SYN в сторону сервера, ACK в сторону клиента, SYN в сторону клиента, ACK в сторону сервера), на практике для экономии времени используется три сегмента.

</details>

9. Какие стандартные коды ответов есть у веб-серверов?

<details>
  <summary>Ответ</summary>

 - 1XX — информационные коды. Они отвечают за процесс передачи данных. Это временные коды, они информируют о том, что запрос принят и обработка будет продолжаться.
 - 2XX — успешная обработка. Запрос был получен и успешно обработан сервером.
 - 3XX — перенаправление (редирект). Эти ответы сервера гласят, что нужно предпринять дальнейшие действия для выполнения запроса. Например, сделать запрос по другому адресу.
 - 4XX — ошибка пользователя. Это значит, что запрос не может быть выполнен по его вине.
 - 5XX — ошибка сервера. Эти коды возникают из-за ошибок на стороне сервера. В данном случае пользователь всё сделал правильно, но сервер не может выполнить запрос. Для кодов этого класса сервер обязательно показывает сообщение, что не может обработать запрос и по какой причине.

</details>

10. Какие существуют основные типы запросов HTTP?

<details>
  <summary>Ответ</summary>

Два наиболее часто используемых видов HTTP запросов это: GET и POST.

GET - запрашивает данные с определенного ресурса (сайта).
POST - отправляет данные на сервер для последующей их обработки.

Особенности GET запроса:
 - Может быть закэширован
 - Остается в истории браузера
 - Может быть закладкой в браузере
 - Не должен использоваться при работе с крайне важными данными
 - Имеет ограниченную длину
 - Должен применяться только для получения данных

Особенности POST запроса:
 - Не кэшируется
 - Не может быть закладкой в браузере
 - Не остаётся в истории браузера
 - Нет ограничений по длине запроса

| Заголовок | Описание |
|-----------|---------------------------------------------------------------------------------------------|
| HEAD | Тоже самое что GET, однако возвращает только HTTP заголовки и не возвращает тело документа. |
| DELETE | Удаляет определенный ресурс. |
| PUT | Загружает представление определенного URI. |
| OPTIONS | Возвращает список видов запросов, поддерживаемых веб-сервером. |
| CONNECT | Создает прозрачный TCP/IP туннель для передачи запросов. |

</details>

11. Где хранятся имена файлов/директорий?
<details>
  <summary>Ответ</summary>

 - Inodes не содержат имён файлов, только другие метаданные файла. 
 - Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса.
 - Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса.

Таким образом имя файла/директории хранится в информационной структуре каталов.
![Структура каталогов](imgs/inf_struct_catalogs.gif)

</details>

12. Как удалить файл с именем `-rf`?

<details>
  <summary>Ответ</summary>

```
rm ./-rf
```

</details>

13. Как посмотреть описание дискриптора? Как посмотреть время последней модификации файла?

<details>
  <summary>Ответ</summary>

Посмотреть полную информацию по дискриптору возможно командой `stat <path_to_file>`.
Время модификации:
```
stat --format=%y dira
```

</details>

14. Для чего нужна переменная окружения PATH?

<details>
  <summary>Ответ</summary>

Переменная окружения PATH содержит абсолютные пути директорий, в которых производится поиск исполняемых файлов при вводе команд

</details>

15. Как посмотреть нагрузку на диски?

<details>
  <summary>Ответ</summary>

Установить утилиту `sysstat`, проверить нагрузку на диски `iostat -xtc`.

</details>

16. Клиент пишет, что заходит на свой сайт и он к нему подключается через раз. Что делать, что спрашивать от клиента? 

<details>
  <summary>Ответ</summary>

Необходимо спросить у клиента какую ошибку он наблюдает при неудачном запросе сайта, в какое время. Если проблема периодическая, то возможно проблема на стороне провайдера клиента. Необходимо запросить у клиента анализ сети с помощью утилит `traceroute`, `mtr` с того узла, где он наблюдает проблему и до сайта

</details>

17. Что такое 127.0.0.1 адрес? Для чего нужен?

<details>
  <summary>Ответ</summary>

127.0.0.1 адрес или localhost доменное имя, а также зарезервированная сеть 127.0.0.1/8 частных IP адресов предназначены для тестирования программы на той же физической машине, где она запускается.

Использование адреса 127.0.0.1 позволяет устанавливать соединение и передавать информацию для программ-серверов, работающих на том же компьютере, что и программа-клиент, независимо от конфигурации аппаратных сетевых средств компьютера (не требуется сетевая карта, модем, и прочее коммуникационное оборудование, интерфейс реализуется при помощи драйвера псевдоустройства в ядре операционной системы)

Так же адрес 127.0.0.1 устанавливается для запрета доступа к сервису из внешней сети. Например: 
```
docker run -d -p 127.0.0.1:3306:3306 mysql
```

</details>

18. Что такое файл в понятиях Unix-like операцинных системах?

<details>
  <summary>Ответ</summary>

Файлы - это объекты, в которые мы записываем информацию и наши данные, исполняемые файлы, но кроме этих привычных нам понятий здесь есть файлы специального назначения - файлы устройств, файлы туннелей, сокетов и многое другое.

Типы файлов в Linux:
- Обычные файлы, для хранения информации;
- Специальные файлы - для устройств и туннелей;
- Директории.

</details>

19. Что такое RAID? Какие массивы бывают?

<details>
  <summary>Ответ</summary>

RAID (Redundant Array of Independent Disks) - избыточный массив независимых дисков, технология виртуализации данных для объединения нескольких физических дисковых устройств в логический модуль для повышения отказоустойчивости и производительности.

В зависимости от количества дисков и класса отказоустойчивости существуют следующие основные типы RAID:
RAID 0:
RAID 1:
RAID 5:
RAID 6:
RAID 10:

</details>

20. При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?

<details>
  <summary>Ответ</summary>

2 диска.

</details>

21. В чем разница между объявлением переменной `export VAR="VALUE"` и `VAR="VALUE"` в bash?

<details>
  <summary>Ответ</summary>

При объявлении переменной через export - переменная будет доступна в любых других процессах, при обычном объявлении переменной - переменная будет доступна только в запущенном процессе.

</details>

22. Как остановить выполнение скрипта в bash при возникновении ошибки в команде?

<details>
  <summary>Ответ</summary>

Команда `set -e` завершит скрипт с ошибкой, в случае, если в нижеследующем bash коде будет обнаружена ошибка. По-умолчанию bash скрипт продолжает работу, если в ходе выполнения возникла ошибка.

</details>

23. Что в bash скрипте означает команда `set -euo pipefail`?

<details>
  <summary>Ответ</summary>

Команда `set` устанавливает аттрибуты оболочки с опеределенных опций.
Опция `-e` - означает, что скрипт будет остановлен, когда произойдет ошибка в ходе его выполнения.
Опция `-u` - означает, что скрипт будет остановлен, если в ходе скрипта, будет обнаружена переменная, которая не определена.
Опция `-o pipefail` - означает, что скрипт будет остановлен, если в ходе пайплайна команд будет выявлена ошибка. 

</details>

24. Как активировать debug режим в bash?

<details>
  <summary>Ответ</summary>

Команда `set -x` в начале скрипта активирует вывод в консоль debug информации.

</details>

25. Что значит `$@` в bash?

<details>
  <summary>Ответ</summary>

`$@` - все параметры переданные скрипту.

</details>

26. Какой код сигнала будет выполнен при исполнении команды `kill <PID>`?

<details>
  <summary>Ответ</summary>

Сигнал SIGTERM (код 15) - это сигнал по-умолчанию отправляемый при вызове команды kill. Это указывает процессу на завершение работы и обычно считается сигналом для использования при чистом завершении работы.

</details>

27. Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?

<details>
  <summary>Ответ</summary>

```
cmd 2>&1 >/dev/null | grep pattern
```

</details>

28. Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?

<details>
  <summary>Ответ</summary>

Команда `w` покажет список пользователей, которые вошли на сервер.

</details>

29. Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?

<details>
  <summary>Ответ</summary>

Необходимо редактировать файл `/etc/ssh/sshd_config`, отвечающий за конфигурацию сервиса ssh.

</details>

30. В каком файле находится информация о смонтированных каталогах в файловую систсему?

<details>
  <summary>Ответ</summary>

Файл `/etc/fstab` содержит информацию о смонтированных каталогах в файловую систему. 

</details>

31. Что выведет команда `cat a` и почему?
```
mkdir  /tmp/abc
cd /tmp/abc
ls >a 2>b
cat a
```

<details>
  <summary>Ответ</summary>

`cat a` выведет
```
a
b
```
Обработка команды идёт справа налево. Сначала создается файл *b*, потом создается файл *a*, команда `ls` отображает список файлов в текущей директории (файлы *a* и *b* уже созданы) в одну колонну и перенаправляет стандартный поток вывода (`>`) в файл *a*, а стандартный поток ошибок `2` в файл *b*. 

</details>

32. Какой транспортный протокол использует DNS? В каком случае DNS работает по UDP, а в каком по TCP?

<details>
  <summary>Ответ</summary>

Все реализации DNS серверов должны поддерживать использование обоих протоколов транспортного уровня (TCP и UDP). Большинство DNS-запросов будет обрабатываться с использованием протокола UDP, исключение составляют трансфер зоны (Query type AXFR) и ответы сервера, превышающие 512 байт на одно сообщение. На вопрос "зачем?" ответ простой -- чтобы не использовались для DDoS.

</details>
  
33. Что такое системный вызов, какие они бывают?

<details>
  <summary>Ответ</summary>

Систе́мный вы́зов  — обращение прикладной программы к ядру операционной системы для выполнения какой-либо операции.

Системные вызовы передают управление ядру операционной системы, которое определяет, предоставлять ли приложению запрашиваемые ресурсы. Если ресурсы доступны, то ядро выполняет запрошенное действие, затем возвращает управление приложению.

В соответствии с документацией системный вызов execve выполняет программу, которая передается ему в параметрах (в данном случае это ls).

Для просмотра документации используйте man 2 stat. Системный вызов stat возвращает информацию об указанном файле. Помните, что все в Linux — файл, включая каталоги.

По умолчанию strace отображает не всю информацию о системных вызовах. Однако у нее есть опция -v verbose, которая покажет дополнительную информацию о каждом системном вызове.

В Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются:
- open,
- read,
- write,
- close,
- wait,
- exec, 
- fork,
- exit,
- kill.

</details>

 34. Что такое сигнал в Unix, зачем они нужны и разница между 9 и 15 сигналами?

<details>
  <summary>Ответ</summary>

Сигнал - в Unix-like операционных системах - асинхронное (в случайное время) уведомление процесса для обработки какого-либо события. Один из основных способов взаимодействия между процессами.

Посылка сигналов от одного процесса к другому обычно осуществляется при помощи системного вызова *kill*. Его первый параметр – PID процесса, которому посылается сигнал; второй параметр – номер сигнала.
```
kill(1111, SIGTERM);
```

Стандарт POSIX определяет 28 сигналов. Некоторые из них:

| Сигнал | Код | Описание |
|-|-|-|
| SIGTERM | 15 | Сигнал завершения (сигнал по умолчанию для утилиты kill) |
| SIGKILL | 9 | Безусловное завершение |
| SIGSTOP | 23 | Остановка выполнения процесса |
| SIGHUP | 1 | Закрытие терминала (перечитать конфигурацию) |
| SIGINT | 2 | Сигнал прерывания (Ctrl-C) с терминала |

</details>

35. Что такое inode? Какая информация там хранится?

<details>
  <summary>Ответ</summary>

Inode (индексный дескриптор) - структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных. Каждый файл в данном каталоге является записью с именем файла и номером индекса. Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. Номера inodes уникальны на уровне раздела. Каждый раздел как собственная таблица индексов. Если у вас закончились inode, вы не можете создавать новые файлы, даже если у вас есть свободное место на данном разделе.

Inodes хранит метаданные о файле, к которому он относится. Эти метаданные содержат всю информацию об указанном файле.
- Размер.
- Разрешение.
- Владелец/группа.
- Расположение жесткого диска.
- Дата/время.
- Любая другая необходимая информация.

</details>

36. Что такое hard link? В чем разница между hard link и soft link? Примеры их практического применения.

<details>
  <summary>Ответ</summary>

**Hard link**:
Ссылка на файл в файловой системе с использованием такогоже inode идентификатора, как у файла, на который ссылаемся.
Создадим файл *realFile*.
```
touch realFile
```
Создадим hard link командой `ln <целевой_файл> <файл_ссылка>`:
```
ln realFile hardLink
```
Проверим, что inode у файла *realFile* и hard ссылке *hardLink* имеют одинаковый идентификатор.
```
$ ls -li
итого 0
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 hardLink
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 realFile
```
Как видно realFile и hardLink имеют одинаковый идентификатор inode.

**Soft link**: 
Создадим soft ссылку на файл *realFile*.
```
ln -s realFile softLink
```
Проверим, что чистовой идентификатор *softLink* отличается от числового идентификатора *realFile*.
```
$ ls -li
итого 0
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 hardLink
2359720 -rw-r--r-- 2 rmntrvn rmntrvn 0 апр 25 23:24 realFile
2366763 lrwxrwxrwx 1 rmntrvn rmntrvn 8 апр 25 23:29 softLink -> realFile
```

Некоторые нюансы:
- Soft ссылки используют различные номера инод, чем основные файлы.
- Soft ссылки становятся полезными, если исходный файл был удален.
- Soft ссылки могут быть созданы из каталогов.
- Soft ссылка может быть создана на пересечении файловых систем.

- Hard ссылка может размещаться только на том же логическом разделе, что и оригинальный файл. Это связано с независимой идентификацией файлов на разных разделах.
- Создание жестких ссылок не поддерживается для папок — только для файлов.
- Файловая система должна поддерживать работу с hard ссылками.

Тепреь кратко рассмотрим основные раззличия при работе с жёсткими и “мягкими” ссылками:

hardlink не может указывать на файл в другой файловой системе (так как inode может принадлежать только одной ФС), а symlink – может.
рри редактировании файла-ссылки в случае с hardlink-ом – изменятся оба файла, так как это один и тот же объект, а в случае с symlink-а  – можно изменять его имя, атрибуты, направить его на другой файл и при этом оригинальный файл не будет затронут (но учтите, что если вы откроете файл симлинка для редактирования – то измените оригинальный файл, т.к. по сути вы откроете для редактирования именно его)
жёсткая ссылка не может указывать на на каталог 
</details>

37. Какие состояния процессов существуют? Что значит состояние процесса D?

<details>
  <summary>Ответ</summary>
Атрибуты процесса

Процесс в ядре представляется просто как структура с множеством полей. 
Поля процесса:

Идентификатор процесса (pid)
Открытые файловые дескрипторы (fd)
Обработчики сигналов (signal handler)
Текущий рабочий каталог (cwd)
Переменные окружения (environ)
Код возврата

Для описания состояний процессов используется несколько моделей. Самая простая модель - это модель трех состояний. Модель состоит из:

состояния выполнения
состояния ожидания
состояния готовности

Более сложная модель - это модель, состоящая из пяти состояний. В этой модели появилось два дополнительных состояния: рождение процесса и смерть процесса. Рождение процесса - это пассивное состояние, когда самого процесса еще нет, но уже готова структура для появления процесса. Как говорится в афоризме: "Мало найти хорошее место, надо его еще застолбить", так вот во время рождения как раз и происходит "застолбление" этого места. Смерть процесса - самого процесса уже нет, но может случиться, что его "место", то есть структура, осталась в списке процессов. Такие процессы называются зобми и о них мы еще поговорим в этой статье.

Над процессами можно производить следующие операции:

Создание процесса - это переход из состояния рождения в состояние готовности
Уничтожение процесса - это переход из состояния выполнения в состояние смерти
Восстановление процесса - переход из состояния готовности в состояние выполнения
Изменение приоритета процесса - переход из выполнения в готовность
Блокирование процесса - переход в состояние ожидания из состояния выполнения
Пробуждение процесса - переход из состояния ожидания в состояние готовности
Запуск процесса (или его выбор) - переход из состояния готовности в состояние выполнения
Для создания процесса операционной системе нужно:

Присвоить процессу имя
Добавить информацию о процессе в список процессов
Определить приоритет процесса
Сформировать блок управления процессом
Предоставить процессу нужные ему ресурсы

Процесс не может взяться из ниоткуда: его обязательно должен запустить какой-то процесс. Процесс, запущенный другим процессом, называется дочерним (child) процессом или потомком. Процесс, который запустил процесс называется родительским (parent), родителем или просто - предком. У каждого процесса есть два атрибута - PID (Process ID) - идентификатор процесса и PPID (Parent Process ID) - идентификатор родительского процесса.

Процессы создают иерархию в виде дерева. Самым "главным" предком, то есть процессом, стоящим на вершине этого дерева, является процесс init (PID=1).

R - процесс выполняется или готов к выполнению (состояние готовности)
D - процесс в "беспробудном сне" - ожидает дискового ввода/вывода
T - процесс остановлен (stopped) или трассируется отладчиком
S - процесс в состоянии ожидания (sleeping)
Z - процесс-зобми
< - процесс с отрицательным значением nice
N - процесс с положительным значением nice (о команде nice мы поговорим позже)
</details>

38. Что такое процесс-зомби и процесс-сирота? Можно ли самостоятельно сделать зомби?

<details>
  <summary>Ответ</summary>

*Процесс-зомби* - дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения.

Удаление зомби возлагается на родительский процесс или системный вызов `wait()` также может это выполнить, поэтому перед ее вызовом не нужно проверять, продолжает ли выполняться требуемый дочерний процесс. Если родительский процесс не удалит своих потомков, то они останутся в состоянии зомби.

Убить зомби-процесс невозможно. Чтобы убить зомби-процесс нужно найти родительский процесс и завершить его или перезапустить. Найти зомби-процессы и их родителей можно следующей командой:
```
ps ajx | grep -w Z
```
PID'ы процессов родителей в 3 колонке. Убить процесс следующей командой:
```
kill -9 <PID процесса родителя>
```

*Процесс-сирота* - — в семействе операционных систем UNIX вспомогательный процесс, чей основной процесс (или связь с ним) был завершен нештатно (не подав сигнала на завершение работы).

---

Отличие в том, что процесс-сирота (orphan process) всё еще активен. Его родительский процесс был по какой-либо причине прерван, и сирота теперь переходит под руководство init, чей ID процесса равен 1. PPID orphan процесса получит значение 1. Пользователь также может создать подобный процесс, отсоединив его от терминала. Сиротские процессы используют много ресурсов, их легко найти с помощью top или htop.

В отличии от процесса-сироты, зомби-процесс неактивен, но контролируется родительским процессом, пока тот не решит, что статус выхода дочерних процессов больше не нужен. Он не использует ресурсы и не может быть запланирован для выполнения. Иногда родительский процесс удерживает дочерний процесс в состоянии зомби, чтобы гарантировать, что будущие дочерние процессы не получат тот же PID. Если вы уничтожите родителя зомби-процесса, зомби-процесс тоже умрет. Для этого найдите родительский PID (PPID) зомби и отправьте ему сигнал SIGCHLD (17): kill -17 ppid.

</details>

39. Что такое файловый дескриптор? Какая информация там хранится?

<details>
  <summary>Ответ</summary>

Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом. 

Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux. Открыли 100 файлов — где-то в ядре появились 100 записей, представленных целыми числами.
Обычно файловые дескрипторы выделяются последовательно. Есть пул свободных номеров. Когда вы создаете новый файл или открываете существующий, ему присваивается номер. Следующий файл получает очередной номер — например, 101, 102, 103 и так далее. 
Дескриптор для каждого процесса является уникальным. Но есть три жестко закрепленных индекса — это первые три номера (0, 1, 2).
Когда вы завершаете работу с файлом, присвоенный ему дескриптор освобождается и возвращается в пул свободных номеров. Он снова доступен для выделения под новый файл. 

Чтобы оценить важность файловых дескрипторов, нужно разобраться, как работает файловая система.
Когда нужно выполнить ввод или вывод, процесс через системный вызов передает ядру дескриптор нужного файла. Ядро обращается к файлу от имени процесса. При этом у самого процесса нет доступа к файлу или таблице индексных дескрипторов
https://habr.com/ru/post/471038/
  

</details>

40. Что такое buffer/cache память? Для чего нужна?

<details>
  <summary>Ответ</summary>

buff/cache память - рассчитанная память, которая зарезервирована, но может быть освобождена при необходимости и используется для быстрого доступа программами к данным, которые находятся в оперативной памяти (быстрой памяти).

buffers — буферы в памяти — страницы памяти, зарезервированные системой для выделения их процессам, когда они затребуют этого, так же известна как heap-memory;
cached — файлы, которые недавно были использованы системой/процессами и хранящиеся в памяти на случай если вскоре они снова потребуются.

</details>

41. Какие DNS записи бывают? Что такое DKIM, DMARC, PTR?

<details>
  <summary>Ответ</summary>

Основные DNS записи:

| Тип | Расшифрока | Описание |
|-|-|-|
| A | Address | Адресная запись, соответствие между именем и IP-адресом. |
| AAAA | Address v6 | Аналог A записи для IPv6 адресов. |
| CNAME | Canonical Name | Каноническое имя для псевдонима (одноуровневая переадресация) |
| MX | Mail Exchanger | Адрес почтового шлюза для домена. Состоит из двух частей — приоритета (чем число больше, тем ниже приоритет), и адреса узла. |
| NS | Authoritative name server | Адрес узла, отвечающего за доменную зону. Критически важна для функционирования самой системы доменных имён. |
| PTR | Pointer | Соответствие адреса имени — обратное соответствие для A и AAAA. |
| SOA | Start of authority | Указание на авторитетность информации, используется для указания на новую зону. |
| TXT | Text string | Запись произвольных двоичных данных, до 255 байт в размере. |
| SPF | Sender Policy Framework | Указывает серверы, которые могут отправлять почту с данного домена. |

DomainKeys Identified Mail (DKIM) — метод E-mail аутентификации, разработанный для обнаружения подделывания сообщений, пересылаемых по email. Метод дает возможность получателю проверить, что письмо действительно было отправлено с заявленного домена. DKIM упрощает борьбу с поддельными адресами отправителей, которые часто используются в фишинговых письмах и в почтовом спаме.

Domain-based Message Authentication, Reporting and Conformance (идентификация сообщений, создание отчётов и определение соответствия по доменному имени) или DMARC — это техническая спецификация, созданная группой организаций, предназначенная для снижения количества спамовых и фишинговых электронных писем, основанная на идентификации почтовых доменов отправителя на основании правил и признаков, заданных на почтовом сервере получателя.

Информация о DKIM и DMARC устанавливается в TXT записи домена.

</details>

42. Что такое RoundRobin DNS как работает?

<details>
  <summary>Ответ</summary>

Round-robin - алгоритм распределения нагрузки распределенной вычислительной системы методом перебора и упорядочения её элементов по круговому циклу.

Round-robin DNS работает, отвечая на запросы не только одним IP-адресом, а списком из нескольких адресов серверов, предоставляющих идентичный сервис. Порядок, в котором возвращаются IP-адреса из списка, основан на алгоритме Round-robin. То есть на практике на доменное имя назначаются несколько IP адресов серверов, которые отвечают на запросы.

</details>

43. Как настроить master-slave репликацию в mysql (кратко)?

<details>
  <summary>Ответ</summary>

Необходимы 2 сервера: master и slave.

1. На обеих сервера устанавливаем сервер MySQL одинаковой версии.
2. Включаем сервер базы данных на обеих серверах.
3. Настраиваем master - в `/etc/my.cnf` устанавливаем слеюущие значения:
```
# выбираем ID сервера, произвольное число, лучше начинать с 1
server-id = 1
# путь к бинарному логу
log_bin = /var/log/mysql/mysql-bin.log
# название Вашей базы данных, которая будет реплицироваться
binlog_do_db = newdatabase
```
Перезапускаем сервер базы данных.
4. Подключаемся к master серверу, создаем пользователя и назначаем ему права для выполнения репликации.
```
mysql -u root -p <пароль root сервера БД>
GRANT REPLICATION SLAVE ON *.* TO 'slave_user'@'%' IDENTIFIED BY 'password';
FLUSH PRIVILEGES;
```
5. На master сервере делаем дамп базы данных c блокировкой таблиц.
```
mysqldump -u root -p --lock-all-tables newdatabase > newdatabase.sql
```
6. Переносим дамп базы на slave сервер, создаем базу данных с таким же именем и импортируем базу.
```
CREATE DATABASE newdatabase;
mysql -u root -p newdatabase < newdatabase.sql
```
7. Настраиваем slave в `/etc/my.cnf`:
```
# ID Слейва, удобно выбирать следующим числом после Мастера
server-id = 2
# Путь к relay логу
relay-log = /var/log/mysql/mysql-relay-bin.log
# Путь к bin логу на Мастере
log_bin = /var/log/mysql/mysql-bin.log
# База данных для репликации
binlog_do_db = newdatabase
```
Перезапускаем сервер базы данных.
8. Запускаем репликацию на slave сервере.
```
CHANGE MASTER TO MASTER_HOST='10.10.0.1', MASTER_USER='slave_user', MASTER_PASSWORD='password',
MASTER_LOG_FILE = 'mysql-bin.000001', MASTER_LOG_POS = 107;
##Указанные значения мы берем из настроек Мастера
После этого запускаем репликацию на Слейве:
START SLAVE;
```
9. Проверяем статус репликации:
```
SHOW SLAVE STATUSG
```

</details>

44. Представлен вывод команды `free`.
```
$ free -m
              total        used        free      shared  buff/cache   available
Mem:           6930        3598         843         183        2489        2919
Swap:         15999           4       15995
```
Почему доступной (available) памяти сейчас 2919, если свободной (free) памяти 843?

<details>
  <summary>Ответ</summary>

- Total. Эта цифра представляет всю существующую память.
- Used вычисление общего значения оперативной памяти системы за вычетом выделенной свободной, разделяемой, буферной и кэш-памяти.
```
used = total - free - buff/cache
```
- Free – свободная память в системе.
- Shared – память, используемая (преимущественно) в tmpfs
- Buffer, и Cache идентифицируют память, используемую для нужд ядра / операционной системы. Буфер и кеш складываются вместе, а сумма указывается в разделе «buff/cache».
- Available – примерное количество оперативной памяти, доступное для запуска новых приложений без использования ими раздела подкачки. В отличие от поля free, это поле принимает в расчёт страницу cache и также то, что не вся рекуперируемая (пригодная для повторного использования) память будет возвращена для рекуперации из-за того, что элементы используются в данный момент.

</details>

45. Вы вводите в строке браузера yandex.ru. Опишите процесс от нажатия клавиши до загрузки страницы.

<details>
  <summary>Ответ</summary>

![](imgs/example-request.jpg)

Любой URL содержит следующую структуру `<протокол>/<хост>/путь`, например `https://yandex.ru/pogoda/samara`. Также URL может содержать данные для отображения страницы.

1. При вводе URL браузер смотрит на протокол запроса. Если протокол в URL не указан, то браузер смотрит на список HSTS (HTTP Strict Transport Security - механизм, принудительно активирующий защищенное соединение через протокол HTTPS), если хост есть в данном списке, то браузер отправит запрос по протоколу HTTPS, если нет, то по HTTP.

2. Для того, чтобы установить соединение с сервером, необходим его IP адрес. Так как мы используем домен, то необходимо установить соответствие домена и IP адреса сервера, где размещается ресурс. При запросе мы обращаемся к DNS. Cначала проверяется кеш DNS. Приоритет опроса DNS кеша следующий:
 - Кеш браузера,
 - Проверяется hosts файл ,
 - Кеш ОС,
 - Кеш роутера,
 - Кеш интернет-провайдера
Если данных о данном запрашиваеомом хосте в кеше нет, то:
 - DNS интернет провайдера отправляет запрос к контевому серверу DNS (.),
 - Если корневой сервер не знает запрашиваемого домена, то он отправляет запрос серверу ответственному за зону (.ru), в которому привязан домен,
 - Если DNS сервер зоны не знает запрашиваемого домена, то запрос отправляется к NS серверу домена.
IP адрес хоста, при его наличии у DNS сервера, возвращается обратно по цепочке

3. После того, как IP адрес хоста получили, необходимо сформировать на прикладном уровне запрос к серверу. К запросу добавляются следующие заголовки:
 - Прикладной уровень: протокол запроса (HTTP/S, FTP и т.д),
 - Транспортный (TCP/UDP): порт, по которому обращаемся к серверу.
 - Сетевой уровень: IP адрес пакета
 - Канальный уровень: определяет есть ли такой адрес в сети. Если нет, то пакет передаётся шлюзу. Устройство шлюза проверяет свою таблицу маршрутизации и направляет пакет в нужном направлении.

4. Далее выполняется следующий алгоритм действий установления соединения:
 - После того, как запрос достиг сервера, клиент отправляет клиенту запрос (client hello) и свою версию протокола TLS на защищенное соединение. 
 - Сервер отвечает клиенту (server hello) с информацией о выбранной версии TLS, методом шифрования, методом компресии и публичный сертификат сервера, подписанный центром сертификации. Сертификат содержит публичный ключ, который будет использован клиентом для шифрования данных. 
 - Клиент подтверждает сертификат сервера с помощью своего списка центров сертификации. Если сертификат подписан центром из списка, то серверу можно доверять.
 - Клиент шифрует данные публичным ключем и отправляет серверу зашифрованное сообщение.
 - Сервер расшифровывает сообщение с помощью своего приватного ключа и генерирует симметричный мастер-ключ и отправляет его клиенту.
 - Клиент отправляет серверу сообщение о финише, шифруя хэш передачи с помощью симметричного ключа.
 - Сервер генерирует собственный хеш, а затем расшифровывает полученный от клиента хэш, чтобы проверить совпадает ли хэш клиента с хэшом сервера. Если совпадение обнаружено, то сервер отправляет клиенту сообщение о финише. 

После этого защищенное соединение с сервером установлено.

5. Далее необходимо сформировать запрос серверу:
 - Клиент формирует запрос HTTP, в котором участвует метод (например GET), URL и версию протокола. Например `GET /pogoda/samara HTTP/2`.
 - Следующий заголовок клиента HOST, в котором указывается к какому хосту необходимо обратиться. Например `HOST: yandex.ru`. По заголовку HOST сервер может определить к какому сайту на сервере необходимо обратиться.
 - Запрос может также содержать и другие заголовки. Необходимо только, чтобы сервер смог понять эти заголовки.

</details>

46. Что такое айнода? какая информация там хранится?
  <details>
    <summary>Ответ</summary>
    inode – это объект файловой системы, содержащий информацию о владельце/группе, которым принадлежит файл или каталог, его права доступа к нему, его размер, тип файла, timestamp-ы отражающие время модификации индексного дескриптора (ctime, changing time), время модификации содержимого файла (mtime, modification time) и время последнего доступа к файлу (atime, access time) и счётчик для учёта количества жёстких ссылок на файл. Каждый inode имеет собственный номер, который присваевается ему файловой системой в момент её создания (форматирования).
 </details>

47. VFS - виртуальная файловая система
   <details>
   <summary>Ответ</summary> 
Виртуальная файловая система (VFS) - это уровень абстракции, который находится над файловой системой и обеспечивает интерфейс между ядром и файловой системой. Через VFS клиентские приложения могут получать доступ к различным файловым системам.
Думайте о виртуальной файловой системе (VFS) как о управляемом контейнере, который фактически обеспечивает функциональность файловой системы.
Во время каждой инициализации файловой системы файловая система регистрируется в VFS. Это происходит, когда операционная система (ОС) инициализируется при запуске. Настоящие файловые системы обычно создаются как загружаемые модули или встроены непосредственно в ядро.

VFS также хранит кэш поисков в каталогах, чтобы легко находить inode для часто используемых каталогов. Например, VFS может прозрачно обращаться к локальным и сетевым устройствам хранения без клиентского приложения, зная фактические файловые системы, и даже может преодолеть несоответствие между файловыми системами Windows, Mac OS и UNIX.
  </details>
 
48. Утилиты df и du что показывают, чем отличаются?
  <details>
   <summary>Ответ</summary> 
Когда доходит дело до проверки свободного места через терминал, нам не обойтись без такой стандартной утилиты, как df. В графическом интерфейсе есть множество программ, которые можно использовать, чтобы узнать свободное место Linux.  Но в некоторых случаях вам доступен только терминал и нужно, например, выяснить почему не работает программа. Тогда на выручку приходит команда df linux, она позволяет выводить не только список подключенных устройств, но и информацию о занятом месте, а также  точку монтирования.

Иногда возникает необходимость посмотреть сколько места занимают файлы в определённой папке и найти самые большие файлы для того чтобы их удалить. Конечно, для решения этих задач существует множество инструментов, но самый простой из них, это утилита du. Она позволяет вывести размер всех файлов в определённой папке в байтах или в более удобном формате.
  
  </details>

49. Что такое VLAN, на каком уровне модели OSI  он работает?
  <details>
   <summary>Ответ</summary> 
VLAN (Virtual Local Area Network, виртуальная локальная сеть) — это функция в роутерах и коммутаторах, позволяющая на одном физическом сетевом интерфейсе (Ethernet, Wi-Fi интерфейсе) создать несколько виртуальных локальных сетей. VLAN используют для создания логической топологии сети, которая никак не зависит от физической топологии.

Достоинства использования VLAN
- Гибкое разделение устройств на группы
Как правило, одному VLAN соответствует одна подсеть. Компьютеры, находящиеся в разных VLAN, будут изолированы друг от друга. Также можно объединить в одну виртуальную сеть компьютеры, подключенные к разным коммутаторам.
- Уменьшение широковещательного трафика в сети
Каждый VLAN представляет отдельный широковещательный домен. Широковещательный трафик не будет транслироваться между разными VLAN. Если на разных коммутаторах настроить один и тот же VLAN, то порты разных коммутаторов будут образовывать один широковещательный домен.
- Увеличение безопасности и управляемости сети
В сети, разбитой на виртуальные подсети, удобно применять политики и правила безопасности для каждого VLAN. Политика будет применена к целой подсети, а не к отдельному устройству.
- Уменьшение количества оборудования и сетевого кабеля
Для создания новой виртуальной локальной сети не требуется покупка коммутатора и прокладка сетевого кабеля. Однако вы должны использовать более дорогие управляемые коммутаторы с поддержкой VLAN.



11. Модель OSI в целом, на каком уровне какие протоколы работают и их особенности
OSI она из 7 уровней и каждый уровень выполняет определенную ему роль и задачи. Разберем, что делает каждый уровень снизу вверх:
Сетевая модель OSI — сетевая модель стека сетевых протоколов OSI/ISO. Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.
1) Физический уровень (Physical Layer): определяет метод передачи данных, какая среда используется (передача электрических сигналов, световых импульсов или радиоэфир), уровень напряжения, метод кодирования двоичных сигналов.
HTTP — «протокол передачи гипертекста» — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.
SMTP — это широко используемый сетевой протокол, предназначенный для передачи электронной почты в сетях TCP/IP.
POP3 -стандартный интернет-протокол прикладного уровня, используемый клиентами электронной почты для получения почты с удалённого сервера по TCP-соединению.

2) Канальный уровень (Data Link Layer): он берет на себя задачу адресации в пределах локальной сети, обнаруживает ошибки, проверяет целостность данных. Если слышали про MAC-адреса и протокол «Ethernet», то они располагаются на этом уровне.

3) Сетевой уровень (Network Layer): этот уровень берет на себя объединения участков сети и выбор оптимального пути (т.е. маршрутизация). Каждое сетевое устройство должно иметь уникальный сетевой адрес в сети. Думаю, многие слышали про протоколы IPv4 и IPv6. Эти протоколы работают на данном уровне.

4) Транспортный уровень (Transport Layer): Этот уровень берет на себя функцию транспорта. К примеру, когда вы скачиваете файл с Интернета, файл в виде сегментов отправляется на Ваш компьютер. Также здесь вводятся понятия портов, которые нужны для указания назначения к конкретной службе. На этом уровне работают протоколы TCP (с установлением соединения) и UDP (без установления соединения).

5) Сеансовый уровень (Session Layer): Роль этого уровня в установлении, управлении и разрыве соединения между двумя хостами. К примеру, когда открываете страницу на веб-сервере, то Вы не единственный посетитель на нем. И вот для того, чтобы поддерживать сеансы со всеми пользователями, нужен сеансовый уровень.

6) Уровень представления (Presentation Layer): Он структурирует информацию в читабельный вид для прикладного уровня. Например, многие компьютеры используют таблицу кодировки ASCII для вывода текстовой информации или формат jpeg для вывода графического изображения.

7) Прикладной уровень (Application Layer): Наверное, это самый понятный для всех уровень. Как раз на этом уроне работают привычные для нас приложения — e-mail, браузеры по протоколу HTTP, FTP и остальное.
    
  </details>

50.Как работает утилита tracerout
<details>
<summary>Ответ</summary> 
Не всегда сеть работает так, как от нее требуется, иногда определенный компьютер в вашей локальной сети компании, или удаленный может не отвечать. Казалось бы, все работает, все подключено, но похоже на каком-то из узлов, на пути от вашего компьютера, до нужного случается ошибка.
Утилита ping позволяет только определить наличие проблемы, что узел не отвечает, но как узнать где обрывается соединение? Для этого применяется утилита traceroure.
Вы, наверное, уже знаете, что вся информация в сети передается в виде пакетов. Поток данных разбивается специальным программным обеспечением на небольшие пакеты и передается через сеть интернет на целевой узел, а там собирается обратно.

Каждый пакет проходит на своем пути определенное количество узлов, пока достигнет своей цели. Причем, каждый пакет имеет свое время жизни. Это количество узлов, которые может пройти пакет перед тем, как он будет уничтожен. Этот параметр записывается в заголовке TTL, каждый маршрутизатор, через который будет проходить пакет уменьшает его на единицу. При TTL=0 пакет уничтожается, а отправителю отсылается сообщение Time Exceeded.

Команда traceroute linux использует UDP пакеты. Она отправляет пакет с TTL=1 и смотрит адрес ответившего узла, дальше TTL=2, TTL=3 и так пока не достигнет цели. Каждый раз отправляется по три пакета и для каждого из них измеряется время прохождения. Пакет отправляется на случайный порт, который, скорее всего, не занят. Когда утилита traceroute получает сообщение от целевого узла о том, что порт недоступен трассировка считается завершенной.
   
  </details>    

51. Где лежат пароли пользователей в ОС?
<details>
<summary>Ответ</summary> 
Изначально для хранения паролей использовался файл /etc/passwd. Но этот файл доступен для чтения всем пользователям. Поэтому, из соображений безопасности, пароли пользователей были перенесены в файл /etc/shadow. Этот файл доступен для чтения только пользователю root.
  </details>  

52. Опишите архитектуру ядра Linux.
<details>
<summary>Ответ</summary> 
Ядро Linux — это центральный компонент операционной системы, который обеспечивает взаимодействие между аппаратным обеспечением и программным обеспечением. 

Архитектура ядра Linux можно описать следующим образом:

Основные характеристики архитектуры ядра Linux:

1. Монолитная архитектура
Ядро Linux является монолитным, что означает, что все основные компоненты, такие как управление процессами, управление памятью и драйверы устройств, находятся в одном адресном пространстве. Это позволяет обеспечить высокую производительность и быстрый обмен данными между различными частями ядра.

2. Модульность
Хотя ядро является монолитным, оно поддерживает модульную архитектуру. Это означает, что драйверы устройств и другие функции могут загружаться и выгружаться динамически во время работы системы. Это позволяет уменьшить потребление памяти и улучшить производительность, так как не все модули должны быть загружены одновременно.

3. Поддержка многозадачности
Ядро Linux поддерживает многозадачность, что позволяет одновременно выполнять несколько процессов. Оно управляет приоритетами процессов и распределяет ресурсы системы для обеспечения эффективной работы.

4. Виртуальная память
Ядро реализует систему виртуальной памяти, позволяющую программам использовать больше памяти, чем физически доступно на устройстве. Это достигается с помощью механизма подкачки (swap), который перемещает данные между оперативной памятью и диском.

5. Управление устройствами
Ядро включает в себя драйверы для различных устройств, которые позволяют взаимодействовать с аппаратным обеспечением. Драйверы могут быть загружены как модули по мере необходимости, что упрощает поддержку нового оборудования.

6. Системные вызовы
Ядро предоставляет интерфейс для взаимодействия с пользовательскими приложениями через системные вызовы. Это позволяет приложениям запрашивать ресурсы и выполнять операции на уровне ядра.

7. Безопасность
Ядро Linux реализует различные механизмы безопасности, такие как контроль доступа и управление правами пользователей, что помогает защитить систему от несанкционированного доступа.

  </details> 

53. Какие основные компоненты включает монолитное ядро Linux
<details>
<summary>Ответ</summary> 
Монолитное ядро Linux включает в себя несколько основных компонентов, которые обеспечивают его функциональность и взаимодействие с аппаратным обеспечением. Вот основные из них:
1. Управление процессами
Описание: Этот компонент отвечает за создание, планирование и завершение процессов. Он управляет состояниями процессов и распределяет ресурсы между ними.
Функции: Планировщик определяет, какие процессы должны выполняться в данный момент, а также управляет их приоритетами.
2. Управление памятью
Описание: Компонент управления памятью отвечает за распределение и управление оперативной памятью.
Функции: Он реализует виртуальную память, что позволяет программам использовать больше памяти, чем физически доступно, и управляет подкачкой страниц между оперативной памятью и диском.
3. Управление устройствами
Описание: Ядро содержит драйверы для различных устройств, таких как сетевые карты, жесткие диски и видеокарты.
Функции: Драйверы обеспечивают взаимодействие между ядром и аппаратным обеспечением, позволяя операционной системе использовать устройства.
4. Системные вызовы
Описание: Системные вызовы предоставляют интерфейс для взаимодействия пользовательских приложений с ядром.
Функции: Они позволяют приложениям запрашивать ресурсы, такие как файлы или сетевые соединения, и выполнять операции на уровне ядра.
5. Сетевой стек
Описание: Этот компонент отвечает за обработку сетевых протоколов и управление сетевыми соединениями.
Функции: Он реализует различные протоколы (например, TCP/IP) и обеспечивает обмен данными между устройствами в сети.
6. Файловая система
Описание: Ядро поддерживает различные файловые системы для хранения и управления данными на дисках.
Функции: Оно обеспечивает доступ к данным, управление файлами и каталогами, а также защиту данных через механизмы прав доступа.
7. Модули ядра
Описание: Поддержка загружаемых модулей позволяет добавлять или удалять функциональность ядра без необходимости перезагрузки системы.
Функции: Это позволяет динамически загружать драйверы устройств или другие компоненты по мере необходимости.
  </details> 
 
54. Опишите общие части файловой системы Unix/Linux, архитектуру файловой системы.
<details>
<summary>Ответ</summary> 
Файловая система Unix/Linux организована в виде иерархической структуры, которая начинается с корневого каталога (/). Эта структура позволяет эффективно управлять файлами и упорядочивать их в логическом порядке. Ниже описаны основные компоненты и архитектура файловой системы Unix/Linux.
Общие части файловой системы Unix/Linux
1. Корневой каталог (/)
Является основным элементом файловой системы. Все другие файлы и каталоги располагаются в иерархии, начинающейся с корня.
2. Стандартные каталоги
/bin: Содержит основные исполняемые программы, доступные всем пользователям (например, ls, cp).
/sbin: Содержит системные утилиты, необходимые для администрирования системы (например, ifconfig, reboot).
/etc: Хранит конфигурационные файлы системы и настройки служб.
/dev: Содержит файлы устройств, которые представляют аппаратные устройства в системе.
/proc: Специальный виртуальный каталог, который предоставляет информацию о состоянии системы и выполняемых процессах.
/var: Содержит изменяемые данные, такие как логи и базы данных.
/usr: Содержит пользовательские приложения и утилиты второго уровня, используемые пользователями.
/tmp: Предназначен для временных файлов, которые могут быть удалены при перезагрузке системы.
/home: Домашние каталоги пользователей.
3. Файлы и директории
В Unix/Linux все представлено в виде файлов, включая устройства и директории. Директории могут содержать файлы и подкаталоги.
Архитектура файловой системы
1. Иерархическая структура
Файловая система организована в виде дерева, где корень (/) является начальной точкой, а все остальные файлы и каталоги располагаются ниже него.
2. Типы файлов
Обычные файлы: Хранят данные (текстовые документы, изображения и т.д.).
Каталоги: Специальные файлы, которые содержат ссылки на другие файлы или каталоги.
Специальные файлы: Представляют устройства (например, /dev/sda для жесткого диска).
3. Метаданные
Каждый файл имеет связанные метаданные, такие как имя файла, размер, дата создания и права доступа. Эти данные хранятся в инодах (inode), которые управляют доступом к данным на диске.
4. Виртуальная файловая система (VFS)
VFS является слоем абстракции между приложениями и физическими файловыми системами. Он позволяет операционной системе работать с различными типами файловых систем единообразно.
5. Разделение на логические группы
Каталоги могут быть разделены на статические (например, /bin, /usr) и динамические (например, /var, /tmp) для упрощения управления данными и обеспечения безопасности.
  </details> 

55. В чем разница между RedHat и Debian?
<details>
<summary>Ответ</summary> 
Различия между Red Hat и Debian заключаются в нескольких ключевых аспектах, включая управление пакетами, философию разработки, целевую аудиторию и поддержку. Вот основные различия:
1. Управление пакетами
Red Hat: Использует RPM (Red Hat Package Manager) для управления пакетами и DNF (или YUM в более старых версиях) для установки и обновления программного обеспечения.
Debian: Использует APT (Advanced Package Tool) и .deb пакеты для управления программами, что позволяет легко устанавливать, обновлять и удалять пакеты.
2. Философия и поддержка
Red Hat: Является коммерческим дистрибутивом с платной поддержкой. Red Hat Enterprise Linux (RHEL) ориентирован на предприятия и предлагает профессиональную техническую поддержку, что делает его популярным выбором для серверов.
Debian: Является полностью бесплатным и поддерживается сообществом. Он более ориентирован на опытных пользователей и системных администраторов, которые ищут стабильность и надежность.
3. Целевая аудитория
Red Hat: Предназначен для корпоративных пользователей, которым нужна надежная поддержка и стабильность в производственных средах.
Debian: Ориентирован на широкий круг пользователей, включая разработчиков и тех, кто ищет гибкость в настройках системы.
4. Частота обновлений
Red Hat: Обновления выходят реже, но они тщательно тестируются на стабильность перед выпуском.
Debian: Часто обновляется, но может быть более консервативным в выборе пакетов. Существует стабильная версия (Stable), которая очень надежна, а также тестовая (Testing) и нестабильная (Unstable) версии для пользователей, желающих использовать более новые пакеты.
5. Структура каталогов
Red Hat: Структура каталогов может быть более ориентирована на серверные приложения с учетом коммерческого использования.
Debian: Структура каталогов часто подразумевает поддержку множества проектов сразу после установки.
  </details> 

56. В чем разница между /proc и /sys?
<details>
<summary>Ответ</summary> 
Разница между /proc и /sys в Linux заключается в их назначении, структуре и типе информации, которую они предоставляют. Вот основные отличия:
1. Назначение
/proc: Изначально создан для предоставления информации о процессах, но со временем расширил свое назначение и теперь содержит множество данных о состоянии системы и ядра. В этом каталоге можно найти информацию о процессах, аппаратном обеспечении, сетевых интерфейсах и других аспектах системы.
/sys: Создан для предоставления структурированной информации о устройствах и драйверах. Он используется для взаимодействия с ядром и управления параметрами устройств, а также для отображения информации о текущей конфигурации системы.
2. Структура
/proc: Не имеет строгой структуры; файлы могут содержать различную информацию в различных форматах. Например, в /proc можно найти файлы, такие как /proc/cpuinfo, которые содержат текстовую информацию о процессоре, или /proc/meminfo, который предоставляет данные о памяти.
/sys: Имеет четкую иерархическую структуру, основанную на объектах ядра (kobjects). Каждый объект в системе (например, устройство) имеет свой каталог с атрибутами, которые могут быть прочитаны или записаны. Это позволяет стандартизировать доступ к информации.
3. Тип информации
/proc: Содержит динамическую информацию о системе и процессах, включая статистику, состояние процессов и параметры конфигурации ядра. Например, /proc/sys позволяет изменять параметры ядра в реальном времени.
/sys: Содержит информацию о устройствах и их свойствах. Например, файлы в /sys/class/net предоставляют информацию о сетевых интерфейсах. Эти файлы могут быть использованы для настройки поведения устройств.
4. Изменяемость
/proc/sys: Позволяет изменять параметры ядра непосредственно через файлы, что делает его важным инструментом для администраторов.
/sys: Также позволяет изменять параметры устройств через соответствующие файлы, что дает возможность управлять поведением оборудования.
  </details> 

57. Мы удалили файл, открывший приложение. Как нам его восстановить?
<details>
<summary>Ответ</summary> 
Первым делом нам нужно убедиться что у нас стоит приложение lsof и примонтирован procfs в /proc.
В этой заметке я буду считать что в системе где будут восстанавливаться открытые файлы все нужные приложения стоят, root доступ есть, всё примонтировано как нужно.

Первым делом нам нужно найти открытый файл с помощью программы lsof:
 sudo lsof | grep filename

Пример:
 sudo lsof | grep /home/anton/.xsession-errors
kwin 2031 4002 anton 2w REG 253,3 4486557 1835028 /home/anton/.xsession-errors

Нас интересуют вот эти значения:
Номер процесса (pid)
Файловый дескриптор (file descriptor)

Здесь я выделю жирным то что нужно:
kwin 2031 4002 anton 2w REG 253,3 4486557 1835028 /home/anton/.xsession-errors

Дальше восстанавливаем его (вы можете также его сохранить в другом месте):
 sudo cp /proc/2031/fd/2 /home/anton/.xsession-error

  </details> 

58. Как посмотреть куда примонтирован procfs в linux
<details>
<summary>Ответ</summary> 
1. Использование команды mount
Вы можете просто выполнить команду mount без параметров, чтобы увидеть все смонтированные файловые системы, включая procfs
Эта команда выведет строки, содержащие информацию о procfs, включая точку монтирования.
2. Проверка файла /proc/mounts
Файл /proc/mounts содержит информацию о всех смонтированных файловых системах. Вы можете использовать следующую команду для его просмотра
Это также покажет, где именно примонтирован procfs.
3. Использование команды df
Команда df может быть использована для отображения информации о файловых системах и их использовании. Вы можете запустить
Это покажет информацию о procfs, включая точку монтирования.
  </details> 

59. Что такое SSH, как организовать доступ на сервер без пароля или с определенных хостов? Как ограничить доступные для выполнения команды?
<details>
<summary>Ответ</summary> 
SSH (Secure Shell) — это криптографический сетевой протокол, который обеспечивает безопасное удаленное соединение между двумя системами. Он широко используется для управления серверами и передачи данных по защищенным каналам.
Организация доступа на сервер без пароля
Чтобы организовать доступ к серверу по SSH без ввода пароля, выполните следующие шаги:
- Создание пары SSH-ключей
- Копирование открытого ключа на сервер
- Проверка доступа

Ограничение доступа с определенных хостов
Если вы хотите ограничить доступ к вашему серверу только с определенных хостов, используйте файл конфигурации SSH (/etc/ssh/sshd_config). Добавьте следующие строки:
text
AllowUsers user@allowed_host
Замените user на имя пользователя и allowed_host на IP-адрес или доменное имя разрешенного хоста. Это позволит только указанному пользователю подключаться с определенного хоста.

Ограничение доступных для выполнения команд
Чтобы ограничить команды, которые может выполнять пользователь по SSH, вы можете использовать механизм "chroot" или настроить ограниченные оболочки (restricted shell). Например, можно использовать rbash (restricted bash):
Установите ограниченную оболочку:
chsh -s /bin/rbash user
Создайте каталог для ограниченного окружения и настройте его:
mkdir /home/user/restricted_env
В каталоге /home/user/restricted_env создайте подкаталоги для необходимых команд и добавьте их в переменную окружения PATH.
Настройте файл .bash_profile в домашнем каталоге пользователя для использования этого окружения.
  </details> 

60. Как проверить потреблённые ресурсы во время сеанса SSH?
- Мониторинг использования ресурсов - top free df -h 
- Отслеживание сетевой активности - iftop

61. Что такое SELinux и зачем он нужен?
<details>
<summary>Ответ</summary> 
SELinux (Security-Enhanced Linux) — это система управления доступом, разработанная Агентством национальной безопасности США (АНБ). Она предназначена для повышения безопасности операционных систем на базе Linux, обеспечивая более строгий контроль доступа к ресурсам системы.

Зачем нужен SELinux?
SELinux необходим для защиты систем от различных угроз и атак. Он помогает:
Защищать конфиденциальные данные от несанкционированного доступа.
Ограничивать возможности вредоносных программ и пользователей в системе.
Обеспечивать дополнительный уровень безопасности для критически важных приложений и служб.
  </details> 

62. Как определить PCI-устройство в системе, например, RAID controller?
<details>
<summary>Ответ</summary> 
Чтобы определить PCI-устройство в системе, например, RAID-контроллер, вы можете воспользоваться командой lspci, которая предоставляет информацию о всех устройствах, подключенных к шине PCI. Вот основные шаги и команды для выполнения этой задачи:
1. Использование команды lspci
Команда lspci выводит список всех устройств, подключенных к шине PCI. Чтобы получить информацию о всех PCI-устройствах, выполните следующую команду:
lspci
2. Фильтрация результатов
Если вы ищете конкретное устройство, например, RAID-контроллер, вы можете использовать grep для фильтрации вывода:
lspci | grep -i raid
Это покажет только те устройства, которые содержат слово "raid" в своем описании.
3. Подробная информация об устройстве
Для получения более подробной информации о конкретном устройстве можно использовать флаг -v (verbose):
lspci -v -s <номер устройства>
Замените <номер устройства> на идентификатор устройства из вывода предыдущей команды (например, 00:1f.2).
  </details> 

63. Как переименовать устройство, например, сетевую карту или диск?
<details>
<summary>Ответ</summary> 
Переименование сетевых интерфейсов
1. Использование правил udev
Для переименования сетевых интерфейсов с помощью udev выполните следующие шаги:
Узнайте MAC-адрес устройства:
Используйте команду ifconfig или ip a для получения информации о сетевых интерфейсах:
ifconfig -a
или
ip a
Создайте правило udev:
Создайте файл правил в директории /etc/udev/rules.d/. Например, создайте файл 79-net-name.rules:
sudo nano /etc/udev/rules.d/79-net-name.rules
Добавьте правило:
Вставьте следующее правило, заменив 08:00:27:17:c3:72 на MAC-адрес вашего устройства и eth0 на желаемое имя:
text
SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="08:00:27:17:c3:72", NAME="eth0"
Перезагрузите систему:
После добавления правила перезагрузите систему, чтобы изменения вступили в силу.
Переименование других устройств (например, дисков)
Для переименования других устройств, таких как диски, можно использовать аналогичный подход с помощью udev, но с разными атрибутами.
Определите устройство:
Используйте команду lsblk или fdisk -l, чтобы найти нужное устройство.
Создайте правило для устройства:
Создайте файл правил в /etc/udev/rules.d/, например, 99-custom-disks.rules, и добавьте правило для вашего устройства.
Пример правила:
text
KERNEL=="sda", NAME="mydisk"
Перезагрузите udev (или систему):
sudo udevadm control --reload-rules
sudo udevadm trigger
  </details> 

64. Что такое LVM? Какие знаете примеры использования?
<details>
<summary>Ответ</summary> 
LVM (Logical Volume Manager) — это система управления логическими томами, которая позволяет более гибко управлять дисковым пространством в операционных системах на базе Linux. Она предоставляет абстракцию над физическими устройствами хранения, позволяя объединять несколько физических томов в одну группу и создавать логические тома, которые могут динамически изменять свой размер.
Основные компоненты LVM
Физические тома (PV): Это физические устройства или их разделы, которые используются для хранения данных. Например, это могут быть жесткие диски или SSD.
Группы томов (VG): Это объединение нескольких физических томов в одно логическое пространство хранения. Группа томов позволяет управлять пространством более эффективно.
Логические тома (LV): Это виртуальные разделы, созданные из пространства группы томов. Логические тома могут быть отформатированы и использоваться как обычные файловые системы.
Примеры использования LVM
Динамическое изменение размера томов: LVM позволяет увеличивать или уменьшать размер логических томов без необходимости перезагрузки системы или отключения файловых систем. Это особенно полезно для серверов, где требуется гибкость в управлении дисковым пространством.
Создание снапшотов: LVM поддерживает создание моментальных снимков (снапшотов) логических томов, что позволяет делать резервные копии данных в определенный момент времени без остановки работы системы.
Объединение нескольких дисков: С помощью LVM можно объединить несколько физических дисков в один логический объем, что упрощает управление хранилищем и повышает его эффективность.
Распределение нагрузки: LVM позволяет распределять данные по нескольким дискам, что может улучшить производительность системы за счет параллельного доступа к данным.
Управление RAID: LVM может быть использован совместно с RAID для создания более сложных конфигураций хранения данных, обеспечивая как избыточность, так и гибкость управления.
  </details>

65. Что такое root reserved space?
<details>
<summary>Ответ</summary> 
Root reserved space (зарезервированное пространство для root) — это механизм в файловых системах Linux, который резервирует определенный процент дискового пространства для пользователя root. Это делается для того, чтобы предотвратить полное заполнение диска обычными пользователями, что может привести к проблемам с работой системы и невозможности выполнения критически важных операций.
  </details> 


<details>
<summary>Ответ</summary> 

  </details> 

66. Что такое exit code и как его узнать?
<details>
<summary>Ответ</summary> 
Exit code (код завершения) — это целочисленное значение, которое программа возвращает родительскому процессу в момент завершения. В Unix-подобных операционных системах, таких как Linux, этот код используется для определения результата выполнения команды или скрипта.

echo $?
  </details> 

67. Почему вывод df -h указывает, что на диске занято мало места, но система не дает записать файл с сообщением “no space left on device”?
<details>
<summary>Ответ</summary> 
Основные причины этой проблемы могут быть следующими:
1. Закончились иноды
Каждый файл в файловой системе использует инод, который хранит метаданные о файле. Если количество доступных инодов исчерпано, вы не сможете создать новые файлы, даже если на диске есть свободное пространство. Чтобы проверить использование инодов, выполните команду:
df -i
Если вы увидите, что процент использования инодов близок к 100%, это означает, что вам нужно удалить ненужные файлы или директории для освобождения инодов.
2. Файловая система заполнена
Иногда файловая система может быть заполнена, даже если df -h показывает свободное место. Это может произойти из-за того, что некоторые процессы используют временные файлы или логи, которые занимают место. Используйте команду du для анализа использования дискового пространства:
du -sh /* | sort -h
Это поможет вам определить, какие директории занимают больше всего места.
3. Ограничения на размер файла
Некоторые файловые системы (например, FAT32) имеют ограничения на максимальный размер файла (например, 4 ГБ). Если вы пытаетесь записать файл, превышающий это ограничение, вы получите сообщение об ошибке.
4. Проблемы с файловой системой
Иногда проблемы с самой файловой системой могут привести к ошибкам записи. В таких случаях рекомендуется проверить файловую систему с помощью команды fsck, но будьте осторожны и убедитесь, что раздел не смонтирован
  </details> 

68. В чем разница между command1 & command2 и command1 && command2, а также command1 && command2 || command3?


69. Из сети резко вырос исходящий трафик на 25-й порт. Как, имея доступ на гейтвей, обнаружить вредителя из внутренней сети?
<details>
<summary>Ответ</summary> 
1. Мониторинг сетевого трафика
Используйте инструменты для анализа сетевого трафика, такие как tcpdump или Wireshark, чтобы захватить пакеты, отправляемые на 25-й порт. Это поможет вам идентифицировать IP-адреса и типы данных, которые отправляются.
sudo tcpdump -i eth0 port 25
Замените eth0 на интерфейс вашего гейтвея.
2. Анализ активных соединений
Используйте команду netstat или ss, чтобы просмотреть активные соединения и определить, какие устройства в вашей сети инициируют соединения на 25-й порт.
netstat -anp | grep ':25'
3. Определение процессов
Если вы видите подозрительные соединения, используйте команду lsof, чтобы узнать, какие процессы используют эти соединения.
sudo lsof -i :25
Это покажет вам, какие процессы на вашем гейтвее или сервере инициируют соединения на 25-й порт.
4. Проверка журналов
Проверьте журналы системы и сетевых устройств на наличие аномальной активности. Это могут быть журналы вашего почтового сервера или системные журналы (/var/log/syslog или /var/log/messages).
5. Использование систем мониторинга
Если у вас есть система мониторинга (например, Zabbix, Nagios или Prometheus), проверьте метрики по трафику и активным соединениям. Это может помочь выявить аномалии в поведении сети.
6. Ограничение доступа
Если вы идентифицировали подозрительное устройство, вы можете временно заблокировать его доступ к сети с помощью правил iptables:
sudo iptables -A INPUT -s <IP-адрес> -j DROP
Замените <IP-адрес> на адрес устройства, которое вызывает подозрения.
Замените <IP-адрес> на адрес устройства, которое вызывает подозрения.
  </details> 

70. Как затюнить параметры Linux Kernel?
<details>
<summary>Ответ</summary> 
1. Изменение параметров во время выполнения
Использование sysctl
sysctl — это утилита, которая позволяет изменять параметры ядра в реальном времени. Например, чтобы установить значение параметра, используйте:
sudo sysctl -w <параметр>=<значение>

Сохранение изменений
Для того чтобы изменения были постоянными после перезагрузки, добавьте параметры в файл конфигурации в /etc/sysctl.d/, например, в /etc/sysctl.d/99-sysctl.conf:
kernel.sysrq = 1
После редактирования файла примените изменения:
sudo sysctl --system
2. Изменение параметров при загрузке
Редактирование конфигурации загрузчика
Чтобы изменить параметры ядра при загрузке, отредактируйте конфигурацию вашего загрузчика (например, GRUB). Откройте файл /etc/default/grub и добавьте необходимые параметры к строке GRUB_CMDLINE_LINUX_DEFAULT. Например:
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash your_parameter=value"
После внесения изменений обновите конфигурацию GRUB:
sudo update-grub
3. Изменение параметров модулей ядра
Если вам нужно передать параметры конкретному модулю ядра, вы можете сделать это в конфигурационных файлах modprobe. Например, создайте файл в /etc/modprobe.d/, например my_module.conf, и добавьте строку:
options my_module parameter=value
  </details> 

71. Что такое ulimits?
Ulimits — это встроенная команда оболочки в Linux, предназначенная для управления ресурсами, доступными для процессов, запущенных в текущей оболочке и её дочерних процессах. Она позволяет устанавливать ограничения на использование различных системных ресурсов, таких как количество открытых файлов, максимальный размер создаваемого файла, объем используемой памяти и другие параметры.
Основные аспекты ulimits
Типы ограничений:
Мягкие ограничения: Эти значения могут быть изменены пользователем в пределах жёстких ограничений. Они позволяют временно менять пределы ресурсов для конкретного процесса.
Жёсткие ограничения: Это максимальные значения ресурсов, которые могут быть установлены для пользователя или процесса. Эти ограничения могут быть изменены только суперпользователем.
Команда ulimit:
Для отображения всех текущих ограничений можно использовать команду:
ulimit -a
Чтобы установить мягкий лимит на максимальный размер файла:
ulimit -f 1024
Для ограничения числа одновременно открытых файловых дескрипторов:
ulimit -n 4096
Постоянные изменения:
Изменения, внесённые с помощью команды ulimit, действуют только в текущей сессии. Чтобы сделать их постоянными, необходимо внести изменения в файлы конфигурации, такие как ~/.bashrc или /etc/security/limits.conf.
Примеры использования
Предотвращение перегрузки системы: Установка ограничений на ресурсы помогает предотвратить ситуации, когда один процесс может заблокировать все ресурсы системы.
Улучшение безопасности: Ограничение размера core-файлов и других ресурсов помогает предотвратить утечки данных и улучшает общую безопасность системы.
Разработка и тестирование: Разработчики могут использовать ulimit для симуляции условий с ограниченными ресурсами, чтобы протестировать работу своих приложений в стрессовых ситуациях.

72. Что такое фрагментация ext3 и ext4?
<details>
<summary>Ответ</summary> 

  </details> 
<details>
<summary>Ответ</summary> 
Фрагментация в файловых системах ext3 и ext4 относится к тому, как данные файлов распределяются по дисковым блокам. Она может влиять на производительность системы, особенно при чтении и записи данных.
Фрагментация в ext3
Внутренняя и внешняя фрагментация:
Внутренняя фрагментация происходит, когда файлы занимают больше места, чем необходимо, из-за того, что они не могут быть размещены в идеально подходящих блоках.
Внешняя фрагментация возникает, когда блоки данных файла разбросаны по диску, что приводит к увеличению времени доступа, поскольку головка чтения/записи должна перемещаться между различными местами на диске.
Стратегии минимизации фрагментации:
Файловая система ext3 пытается минимизировать внешнюю фрагментацию, группируя блоки для новых файлов и используя кэширование записи для записи данных в непрерывные области.
Однако при интенсивной работе с файлами (например, на почтовых серверах) может возникнуть значительная фрагментация свободных областей даже при наличии большого объема свободного пространства.
Отсутствие дефрагментации:
В ext3 нет встроенной утилиты для дефрагментации. Единственный способ улучшить ситуацию — это копировать файлы в новую файловую систему или архивировать их.
Фрагментация в ext4
Улучшенные механизмы управления фрагментацией:
Файловая система ext4 значительно улучшила управление фрагментацией по сравнению с ext3. Она использует выделение блоков группами (multiblock allocation), что позволяет хранить данные более компактно и минимизировать фрагментацию.
Ext4 также поддерживает online defragmentation с помощью утилиты e4defrag, что позволяет выполнять дефрагментацию без необходимости размонтирования файловой системы.
Профилактика фрагментации:
Ext4 выделяет место для файлов заранее, что помогает избежать фрагментации при записи больших файлов.
Даже если фрагментация возникает, система старается переместить файлы в свободные области, что снижает влияние на производительность.
  </details> 

73. Зачем файловые системы ext* резервируют 5% места?
Файловые системы ext3 и ext4 резервируют 5% от общего объема дискового раздела для нужд пользователя root. 

74. Как увеличить размер файловой системы?
<details>
<summary>Ответ</summary> 
Шаги для увеличения размера файловой системы
Увеличение объема диска:
Если вы используете виртуальную машину, сначала увеличьте размер виртуального диска через интерфейс гипервизора (например, VMware, VirtualBox или другой).
Проверка доступного пространства:
После увеличения диска проверьте доступное пространство с помощью команды:

lsblk
Расширение раздела:
Если вы используете стандартные разделы (не LVM), вы можете использовать утилиту growpart для изменения размера раздела. Установите её, если она не установлена:
Для Debian/Ubuntu:

sudo apt-get install cloud-guest-utils
Для CentOS/RHEL:

sudo yum install cloud-utils-growpart
Затем выполните команду для изменения размера раздела:

sudo growpart /dev/sda 1
Замените /dev/sda на ваш диск и 1 на номер раздела.
Изменение размера файловой системы:
После изменения размера раздела необходимо изменить размер файловой системы. В зависимости от типа файловой системы используйте соответствующую команду:
Для ext4:

sudo resize2fs /dev/sda1
Для XFS:

sudo xfs_growfs /dev/sda1
Проверка изменений:
После выполнения всех шагов проверьте новый размер файловой системы с помощью команды:

df -h
  </details> 

75. Можем ли мы уменьшить размер файловой системы?
<details>
<summary>Ответ</summary> 
Шаги для уменьшения размера файловой системы
Проверка файловой системы:
Перед началом процесса обязательно проверьте файловую систему на наличие ошибок. Если она смонтирована, сначала размонтируйте её:

sudo umount /dev/sda1
Затем выполните проверку:

sudo e2fsck -f /dev/sda1
Уменьшение размера файловой системы:
Используйте команду resize2fs, чтобы уменьшить размер файловой системы. Укажите новый размер в параметрах:

sudo resize2fs /dev/sda1 16G
Здесь 16G — это новый размер, который вы хотите установить.
Уменьшение размера раздела:
После изменения размера файловой системы вам нужно уменьшить размер самого раздела. Для этого используйте утилиту parted:

sudo parted /dev/sda
Внутри утилиты выполните команду для изменения размера раздела:
text
(parted) resizepart 1 16GB
Монтирование файловой системы:
После завершения всех изменений вы можете снова смонтировать файловую систему:

sudo mount /dev/sda1 /mnt
Проверка результата:
Убедитесь, что изменения были успешными, с помощью команды:

df -h | grep /dev/sda1
Важные замечания
Резервное копирование: Перед выполнением любых операций по изменению размера всегда рекомендуется делать резервную копию важных данных.
Поддержка файловых систем: Не все файловые системы поддерживают уменьшение размера. Например, XFS не позволяет уменьшать размер разделов.
Время выполнения: Процесс может занять продолжительное время в зависимости от объема данных и скорости диска.
  </details> 

76. Что такое chroot и для чего он нужен?
<details>
<summary>Ответ</summary> 
Chroot (от англ. change root) — это системный вызов и утилита в Unix-подобных операционных системах, которая позволяет изменить корневой каталог для запущенного процесса и его дочерних процессов. Это создаёт изолированное окружение, известное как chroot jail, в котором программа не может получить доступ к файлам вне нового корневого каталога.
Основные функции и применения chroot
Изоляция процессов: Chroot используется для создания безопасной среды, в которой процессы могут работать без доступа к остальной файловой системе. Это особенно полезно для повышения безопасности, так как ограничивает доступ к критически важным системным файлам.
Восстановление системы: Chroot часто применяется при восстановлении системы после сбоев. Например, если система не загружается, можно загрузиться с LiveCD или USB и использовать chroot для доступа к файловой системе, чтобы исправить проблемы или сбросить пароль пользователя root.
Тестирование и разработка: Chroot позволяет создавать изолированные окружения для тестирования программного обеспечения или сборки пакетов. Это помогает избежать конфликтов с установленными библиотеками и зависимостями в основной системе.
Создание чистых окружений: В разработке программного обеспечения chroot может использоваться для создания "чистых" сред, где можно безопасно устанавливать и тестировать новые пакеты без влияния на основную систему.
  </details>

77. У нас есть Linux box с 2 Гб оперативной памяти и Java-приложение, которое пытается выделить 4 Гб во время запуска. Удастся ли это?
<details>
<summary>Ответ</summary> 
Запуск Java-приложения, которое пытается выделить 4 Гб оперативной памяти на системе с 2 Гб RAM, не удастся. Вот основные причины:
Причины неудачи
Недостаток физической памяти: Операционная система не сможет выделить 4 Гб памяти, если в системе всего 2 Гб оперативной памяти. Java Virtual Machine (JVM) попытается выделить больше памяти, чем доступно, что приведет к ошибке.
Параметры JVM: При запуске Java-приложения можно указать максимальный размер кучи с помощью параметра -Xmx. Например:
bash
java -Xmx4g YourApplication
Однако в данном случае JVM не сможет выполнить эту команду из-за недостатка физической памяти.
Системные ограничения: Даже если бы в системе была возможность использования виртуальной памяти (например, через своп-файл), попытка выделить 4 Гб может привести к проблемам с производительностью и стабильностью системы.
  </details>

78. Есть приложение, которое читает файл, который пользователь пытается удалить. Что случится? Можно ли удалить этот файл? Можно ли восстановить этот файл?
<details>
<summary>Ответ</summary> 
В Linux создание процессов осуществляется с использованием нескольких ключевых механизмов. Основные из них включают:
1. Системный вызов fork()
fork() создает новый процесс, который является копией вызывающего (родительского) процесса. После вызова fork() у вас есть два процесса: родительский и дочерний.
В дочернем процессе fork() возвращает 0, а в родительском — PID дочернего процесса. Это позволяет различать, какой процесс выполняет код.
Оба процесса имеют свои собственные адресные пространства, но используют общие открытые файловые дескрипторы.
2. Системный вызов exec()
После создания дочернего процесса с помощью fork(), если нужно запустить другую программу, используется один из вызовов exec (например, execve, execl, execvp и т.д.).
exec() заменяет текущий процесс новым исполняемым файлом, загружая его в память и начиная выполнение.
3. Системный вызов vfork()
vfork() создаёт новый процесс, но не копирует адресное пространство родителя. Вместо этого дочерний процесс использует адресное пространство родителя до тех пор, пока не выполнит exec().
Это более эффективный способ создания процессов, когда ожидается немедленное выполнение другой программы.
4. Системный вызов clone()
clone() используется для создания потоков (threads) и позволяет более гибко управлять тем, какие ресурсы будут разделяться между родительским и дочерним процессами.
  </details>


79. Какие механизмы создания процессов в Linux вы знаете?
<details>
<summary>Ответ</summary> 
В Linux создание процессов осуществляется с использованием нескольких ключевых механизмов. Основные из них включают:
1. Системный вызов fork()
fork() создает новый процесс, который является копией вызывающего (родительского) процесса. После вызова fork() у вас есть два процесса: родительский и дочерний.
В дочернем процессе fork() возвращает 0, а в родительском — PID дочернего процесса. Это позволяет различать, какой процесс выполняет код.
Оба процесса имеют свои собственные адресные пространства, но используют общие открытые файловые дескрипторы.
2. Системный вызов exec()
После создания дочернего процесса с помощью fork(), если нужно запустить другую программу, используется один из вызовов exec (например, execve, execl, execvp и т.д.).
exec() заменяет текущий процесс новым исполняемым файлом, загружая его в память и начиная выполнение.
3. Системный вызов vfork()
vfork() создаёт новый процесс, но не копирует адресное пространство родителя. Вместо этого дочерний процесс использует адресное пространство родителя до тех пор, пока не выполнит exec().
Это более эффективный способ создания процессов, когда ожидается немедленное выполнение другой программы.
4. Системный вызов clone()
clone() используется для создания потоков (threads) и позволяет более гибко управлять тем, какие ресурсы будут разделяться между родительским и дочерним процессами.
  </details>

80. Сравните systemd и init system.
<details>
<summary>Ответ</summary> 
Сравнение systemd и init (в частности, SysVinit) можно провести по нескольким ключевым аспектам, включая архитектуру, производительность, управление службами и функциональные возможности.
1. Архитектура
Init (SysVinit):
Это традиционная система инициализации, которая использует последовательный подход к запуску служб. Она запускает службы в определенном порядке, основываясь на сценариях, написанных в оболочке.
Каждая служба определяется в виде отдельного скрипта, что может усложнять управление зависимостями и порядок запуска.
Systemd:
Это более современная система инициализации, разработанная для работы с параллельным запуском служб. Она использует концепцию "юнитов" (unit files), которые описывают службы и их зависимости.
Systemd позволяет явно указывать зависимости между службами, что улучшает управление порядком их запуска.
2. Производительность
Init (SysVinit):
Поскольку SysVinit запускает службы последовательно, это может приводить к более длительному времени загрузки системы.
Отсутствие параллелизма делает его менее эффективным на современных системах с многоядерными процессорами.
Systemd:
Systemd значительно ускоряет процесс загрузки за счет распараллеливания запуска служб. Это позволяет системе загружаться быстрее, так как независимые службы могут запускаться одновременно.
Время загрузки может быть сокращено до нескольких секунд благодаря оптимизированному управлению процессами.
3. Управление службами
Init (SysVinit):
Управление службами осуществляется через скрипты в /etc/init.d/ и символические ссылки в /etc/rc*.d/. Это требует ручного редактирования скриптов для изменения конфигурации.
Отсутствие централизованного управления затрудняет администрирование.
Systemd:
Systemd предоставляет команду systemctl, которая является единой точкой управления для всех служб. С помощью этой команды можно запускать, останавливать и проверять статус служб.
Логирование интегрировано через journald, что упрощает просмотр логов и диагностику проблем.
4. Функциональные возможности
Init (SysVinit):
Основная функциональность ограничивается запуском и остановкой служб. Он не поддерживает сложные механизмы управления зависимостями или параллельный запуск.
Systemd:
Включает множество дополнительных функций, таких как управление ресурсами через cgroups, отложенный запуск служб, таймеры и улучшенное управление пользователями через systemd-logind.
Позволяет создавать сложные зависимости между службами и управлять ими более эффективно.
  </details>

81. У вас есть папка с большим количеством файлов, и вы хотите удалить все файлы с именами, начинающимися на A (прописная буква). Но команда rm –f A* выдает Argument list too long. Как удалить эти файлы?
<details>
<summary>Ответ</summary> 
Чтобы удалить все файлы с именами, начинающимися на "A" в папке, но столкнувшись с ошибкой "Argument list too long" при использовании команды rm -f A*, вы можете воспользоваться несколькими альтернативными методами. Вот некоторые из них:
1. Использование команды find
Команда find позволяет обойти ограничение на длину аргумента, так как она обрабатывает файлы по одному. Вы можете использовать следующую команду:
bash
find . -type f -name 'A*' -exec rm -f {} +
. указывает на текущую директорию.
-type f фильтрует только файлы.
-name 'A*' ищет файлы, начинающиеся на "A".
-exec rm -f {} + удаляет найденные файлы.
2. Использование цикла for
Если вы хотите использовать цикл, вы можете сделать это следующим образом:
bash
for file in A*; do
    [ -e "$file" ] && rm -f "$file"
done
Этот скрипт перебирает все файлы, начинающиеся на "A", и удаляет их, проверяя, существует ли файл перед удалением.
3. Использование xargs
Вы также можете использовать xargs, чтобы передать список файлов команде rm:
bash
find . -type f -name 'A*' | xargs rm -f
Этот метод также позволяет избежать проблемы с длинными аргументами.
  </details>

82. Расскажите о модели OSI. Опишите функции и назначение каждого уровня.

<details>
<summary>Ответ</summary> 
Модель OSI (Open Systems Interconnection) — это концептуальная модель, разработанная для стандартизации процессов сетевого взаимодействия. Она разбивает процесс передачи данных на семь уровней, каждый из которых выполняет определённые функции. Рассмотрим подробнее каждый уровень и его назначение.
1. Физический уровень (Physical Layer)
Функции: Определяет электрические, механические и функциональные характеристики для активации и поддержания физических соединений между устройствами.
Назначение: Обеспечивает передачу битов (нулей и единиц) по физическим каналам, таким как кабели, радиоволны и оптоволокно.
Примеры: Ethernet, RS-232, RJ45, оптоволоконные кабели.
2. Канальный уровень (Data Link Layer)
Функции: Обеспечивает надежную передачу данных через физический канал, выполняет обнаружение и исправление ошибок, а также управление доступом к среде передачи.
Назначение: Формирует фреймы данных и управляет их передачей между узлами сети.
Примеры: Ethernet, MAC-адреса, протоколы PPP и HDLC.
3. Сетевой уровень (Network Layer)
Функции: Отвечает за маршрутизацию пакетов данных между устройствами в разных сетях. Обрабатывает логические адреса (например, IP-адреса).
Назначение: Определяет маршрут для передачи данных от источника к получателю через множество промежуточных устройств.
Примеры: IP (Internet Protocol), ICMP (Internet Control Message Protocol).
4. Транспортный уровень (Transport Layer)
Функции: Обеспечивает надежную передачу данных между конечными системами. Делит данные на сегменты и управляет их порядком доставки.
Назначение: Гарантирует целостность данных и управление потоком.
Примеры: TCP (Transmission Control Protocol), UDP (User Datagram Protocol).
5. Сеансовый уровень (Session Layer)
Функции: Устанавливает, управляет и завершает сеансы связи между приложениями.
Назначение: Обеспечивает синхронизацию и управление обменом данными между приложениями.
Примеры: Протоколы X.225, ISO 8327.
6. Уровень представления (Presentation Layer)
Функции: Отвечает за преобразование форматов данных, включая сжатие и шифрование.
Назначение: Обеспечивает совместимость между различными форматами данных, позволяя приложениям корректно интерпретировать информацию.
Примеры: Форматы JPEG, MPEG, SSL/TLS для шифрования.
7. Прикладной уровень (Application Layer)
Функции: Предоставляет интерфейс для взаимодействия пользователей с сетевыми приложениями.
Назначение: Позволяет приложениям использовать сетевые услуги для передачи данных.
Примеры: HTTP/HTTPS (для веб-сайтов), FTP (для передачи файлов), SMTP (для электронной почты).
  </details>

83. Какие сетевые топологии вы знаете? Опишите разницу между ними.
<details>
<summary>Ответ</summary> 
Сетевые топологии описывают способы соединения устройств в сети и могут значительно влиять на производительность, надежность и стоимость сети. Рассмотрим основные типы сетевых топологий и их отличия.
1. Шинная топология (Bus Topology)
Описание: Все устройства подключены к единой магистрали (кабелю), по которой передаются данные. На концах кабеля установлены терминаторы для предотвращения отражения сигналов.
Преимущества:
Простота установки и настройки.
Низкие затраты на оборудование.
Недостатки:
Если кабель поврежден, вся сеть выходит из строя.
Ограниченная длина кабеля и количество устройств.
Низкая производительность при увеличении числа пользователей.
2. Кольцевая топология (Ring Topology)
Описание: Каждое устройство соединено с двумя соседними, образуя замкнутое кольцо. Данные передаются по кольцу в одном направлении.
Преимущества:
Легкость в настройке и управлении.
Простой процесс передачи данных.
Недостатки:
Выход одного устройства из строя приводит к сбою всей сети.
Задержки при передаче данных могут увеличиваться с ростом числа узлов.
3. Звездная топология (Star Topology)
Описание: Все устройства подключены к центральному устройству (концентратору или коммутатору). Данные передаются через центральное устройство.
Преимущества:
Высокая надежность: выход из строя одного устройства не влияет на работу остальных.
Легкость в добавлении новых устройств.
Недостатки:
Если центральное устройство выходит из строя, вся сеть перестает функционировать.
Более высокие затраты на оборудование по сравнению с шинной и кольцевой топологиями.
4. Ячеистая топология (Mesh Topology)
Описание: Каждое устройство подключено ко всем другим устройствам, создавая множество путей для передачи данных.
Преимущества:
Высокая надежность и отказоустойчивость: если один путь поврежден, данные могут быть перенаправлены по другому пути.
Недостатки:
Высокие затраты на кабели и оборудование из-за большого количества соединений.
Сложность настройки и управления сетью.
5. Древовидная топология (Tree Topology)
Описание: Комбинация звёздной и шинной топологий, где группы устройств соединены в виде иерархии. Центральный узел соединен с несколькими подузлами.
Преимущества:
Гибкость в добавлении новых узлов и расширении сети.
Недостатки:
Если главный узел выходит из строя, это может повлиять на работу всех подузлов.
  </details>

84. Зачем нужен IP-адрес, если MAC-адрес уникален? Разве мы не можем общаться только по MAC-адресу?
<details>
<summary>Ответ</summary> 
IP-адреса и MAC-адреса выполняют разные, но взаимодополняющие функции в сетевом взаимодействии. Вот основные причины, почему оба типа адресов необходимы, а также различия между ними.
Зачем нужен IP-адрес, если MAC-адрес уникален?
Разные уровни модели OSI:
MAC-адрес работает на канальном уровне (Data Link Layer) модели OSI и используется для идентификации устройств в пределах локальной сети. Он уникален для каждого сетевого интерфейса и не изменяется.
IP-адрес работает на сетевом уровне (Network Layer) и используется для маршрутизации данных между различными сетями. Он определяет местоположение устройства в сети и может изменяться в зависимости от сети, к которой устройство подключено.
Маршрутизация данных:
IP-адреса необходимы для передачи данных между различными сетями. Они позволяют маршрутизаторам определять, куда направлять пакеты данных, когда они перемещаются через Интернет или другие сети.
MAC-адреса не могут использоваться для маршрутизации за пределами локальной сети, так как они не уникальны в глобальном масштабе.
Гибкость и динамичность:
IP-адреса могут назначаться динамически (например, с помощью DHCP) или статически, что позволяет устройствам легко менять свои адреса при подключении к различным сетям.
MAC-адреса фиксированы и назначаются производителем устройства, что делает их менее гибкими.
Обработка широковещательных и многоадресных рассылок:
IP-адреса могут использоваться для широковещательной передачи (broadcast) и многоадресной передачи (multicast), что позволяет эффективно передавать данные нескольким получателям одновременно.
MAC-адреса также поддерживают широковещательные передачи, но только в пределах одной локальной сети.
  </details>

85. В чем разница между концентратором и коммутатором L2 в сетях Ethernet?
<details>
<summary>Ответ</summary> 
Концентраторы и коммутаторы уровня 2 (L2) — это сетевые устройства, используемые в Ethernet-сетях, но они имеют разные функции и характеристики. Рассмотрим ключевые различия между ними.
1. Уровень работы
Концентратор:
Работает на физическом уровне (уровень 1) модели OSI.
Он просто передает данные, полученные от одного порта, всем остальным портам без какой-либо обработки.
Коммутатор L2:
Работает на канальном уровне (уровень 2) модели OSI.
Использует MAC-адреса для управления передачей данных и принимает решения о том, куда отправлять пакеты.
2. Обработка данных
Концентратор:
Принимает входящий сигнал и отправляет его на все порты, что приводит к увеличению сетевого трафика и потенциальным коллизиям.
Не осуществляет никакой фильтрации или маршрутизации данных.
Коммутатор L2:
Создает таблицу MAC-адресов, которая помогает определить, на какой порт отправить данные. Это позволяет ему пересылать пакеты только на нужный порт, а не на все устройства в сети.
Уменьшает ненужный трафик и повышает общую производительность сети.
3. Домен коллизий
Концентратор:
Создает единый домен коллизий для всех подключенных устройств. Это означает, что если одно устройство пытается передать данные, другие устройства могут столкнуться с коллизией.
Коммутатор L2:
Создает отдельные домены коллизий для каждого порта. Это позволяет избежать коллизий между устройствами, подключенными к разным портам коммутатора.
4. Эффективность и производительность
Концентратор:
Менее эффективен из-за широковещательной передачи данных. Это может привести к перегрузке сети и снижению производительности при увеличении числа подключенных устройств.
Коммутатор L2:
Более эффективен благодаря интеллектуальной пересылке данных. Он уменьшает количество коллизий и оптимизирует использование полосы пропускания.
  </details>

86. Какой номер порта используется для PING-коммуникации?
<details>
<summary>Ответ</summary> 
PING — это утилита, используемая для проверки доступности удаленных устройств в сети, и она работает на основе протокола ICMP (Internet Control Message Protocol). Важно отметить, что PING не использует номера портов, так как он работает на сетевом уровне, а не на транспортном.
Причины, почему PING не использует номера портов:
Протокол ICMP: PING отправляет ICMP Echo Request пакеты и ожидает ICMP Echo Reply от целевого устройства. ICMP не использует порты, как это делают транспортные протоколы, такие как TCP и UDP. Поэтому PING не может "пинговать" конкретный порт.
Уровень модели OSI: PING работает на сетевом уровне (уровень 3) модели OSI, тогда как номера портов относятся к транспортному уровню (уровень 4). Это означает, что PING проверяет доступность устройства по IP-адресу, а не по порту.
  </details>

87. Зачем нам маршрутизатор по умолчанию?
<details>
<summary>Ответ</summary> 
Маршрутизатор по умолчанию (или шлюз по умолчанию) — это сетевое устройство, к которому направляются все пакеты данных, если для них не найден более конкретный маршрут. Он играет ключевую роль в маршрутизации трафика в сети, обеспечивая связь между локальной сетью и внешними сетями, такими как Интернет.
Зачем нужен маршрутизатор по умолчанию?
Упрощение маршрутизации:
В сетях часто бывает много устройств, и не всегда возможно заранее определить маршруты для всех возможных адресов назначения. Маршрутизатор по умолчанию служит "универсальной дверью", через которую проходят все пакеты, для которых нет явного маршрута в таблице маршрутизации. Это упрощает управление сетью и делает её более гибкой14.
Обеспечение доступа к другим сетям:
Если устройство в локальной сети хочет отправить данные за её пределы (например, в Интернет), оно отправляет пакеты на маршрутизатор по умолчанию. Этот маршрутизатор затем определяет наилучший путь для передачи данных дальше67.
Оптимизация работы сети:
Маршрутизатор по умолчанию помогает минимизировать задержки и перегрузки, находя оптимальные пути для передачи данных. Это особенно важно в крупных сетях, где эффективность маршрутизации напрямую влияет на производительность12.
Управление IP-адресами:
В некоторых случаях маршрутизатор по умолчанию также может назначать IP-адреса устройствам внутри локальной сети, что упрощает администрирование и управление подключениями14.
  </details>

88. Как хост решает DNS по умолчанию?
<details>
<summary>Ответ</summary> 
Хост решает DNS по умолчанию, используя несколько шагов и механизмов. Вот основные аспекты этого процесса:
1. Конфигурация DNS-серверов
Каждый хост (например, компьютер или сервер) настраивается для использования определённых DNS-серверов. Эти настройки могут быть указаны в конфигурационных файлах операционной системы или через интерфейс управления сетевыми параметрами.
Windows: В настройках сети можно указать адреса DNS-серверов, которые будут использоваться по умолчанию.
Linux: Обычно используется файл /etc/resolv.conf, где указываются адреса DNS-серверов.
2. Поиск в локальном кэше
Перед отправкой запроса на внешний DNS-сервер, хост сначала проверяет локальный кэш DNS. Если запрашиваемое доменное имя уже было разрешено ранее, хост использует закэшированный IP-адрес, что ускоряет процесс и снижает нагрузку на сеть.
3. Запрос к DNS-серверу
Если IP-адрес не найден в локальном кэше, хост отправляет запрос на указанный DNS-сервер. Это может быть:
Публичный DNS-сервер (например, Google DNS 8.8.8.8).
DNS-сервер провайдера.
Локальный DNS-сервер, если он настроен.
Запрос обычно осуществляется через UDP на порт 53.
4. Рекурсивный поиск
Если запрашиваемый DNS-сервер не знает ответ на запрос (например, если он не имеет записи для данного доменного имени), он может выполнить рекурсивный поиск, обращаясь к другим DNS-серверам (например, корневым серверам и серверам доменов верхнего уровня).
5. Ответ от DNS-сервера
Когда DNS-сервер находит нужную запись, он возвращает IP-адрес обратно хосту. Этот адрес может быть также сохранён в локальном кэше для будущих запросов.
6. Использование полученного IP-адреса
После получения IP-адреса хост может использовать его для установления соединения с удалённым сервером или устройством.
  </details>

89. Компьютер начал получать IP-адрес из другой сети (есть подозрение, что в сети работает другой DHCP-сервер): как его найти и отключить? Какие методы защиты от такой проблемы?
<details>
<summary>Ответ</summary> 
Если ваш компьютер начинает получать IP-адрес из другой сети, это может указывать на наличие неавторизованного DHCP-сервера в вашей сети. Чтобы найти и отключить этот сервер, а также защититься от подобных проблем в будущем, можно использовать следующие методы:
Поиск и отключение неавторизованного DHCP-сервера
Проверка активных DHCP-серверов:
Используйте команду arp -a для просмотра ARP-таблицы и определения MAC-адресов устройств в сети. Это может помочь идентифицировать потенциальные DHCP-серверы.
Используйте утилиты, такие как nmap, для сканирования сети и поиска активных DHCP-серверов:
bash
nmap --script broadcast-dhcp-discover
Анализ сетевого трафика:
Используйте инструменты анализа трафика, такие как Wireshark, для захвата пакетов DHCP. Вы можете фильтровать по протоколу DHCP и просмотреть ответы от различных серверов.
Обратите внимание на пакеты DHCP Offer и DHCP ACK, чтобы определить источник.
Отключение устройства:
После идентификации неавторизованного DHCP-сервера (например, роутера или другого устройства), отключите его от сети или измените его настройки, чтобы он не работал как DHCP-сервер.
Методы защиты от неавторизованных DHCP-серверов
DHCP Snooping:
Включите функцию DHCP Snooping на всех коммутаторах в вашей сети. Это позволит фильтровать DHCP-пакеты и разрешать только те ответы, которые приходят с доверенных портов.
Настройте порты как доверенные (trusted) для тех, к которым подключены авторизованные DHCP-серверы, и как недоверенные (untrusted) для клиентских подключений.
Port Security:
Настройте Port Security на коммутаторах для ограничения количества MAC-адресов на порту. Это поможет предотвратить подмену MAC-адресов и защитить сеть от атак.
Установите режим реагирования на нарушение правил безопасности (например, shutdown), чтобы отключить порт при попытке подключения несанкционированного устройства.
Мониторинг сети:
Регулярно проверяйте сеть на наличие новых устройств и следите за изменениями в конфигурации.
Используйте системы мониторинга для отслеживания активности DHCP и других сетевых параметров.
Фильтрация по MAC-адресам:
Настройте фильтрацию по MAC-адресам на уровне коммутаторов или маршрутизаторов, чтобы разрешать доступ только известным устройствам.
  </details>

90. Мы будем мигрировать сайт на новый IP-адрес. Как сделать, чтобы пользователи этого практически не заметили?
<details>
<summary>Ответ</summary> 
Для того чтобы пользователи практически не заметили миграцию сайта на новый IP-адрес, можно следовать нескольким ключевым шагам:
1. Подготовка к миграции
Создание резервной копии: Перед началом миграции создайте резервные копии всех файлов сайта и базы данных. Это поможет избежать потери данных.
Настройка нового сервера: Убедитесь, что новый сервер настроен и готов к работе. Перенесите все файлы и базу данных на новый сервер и протестируйте сайт, чтобы убедиться, что он функционирует корректно.
2. Изменение DNS-записей
Снижение TTL: Перед изменением IP-адреса в DNS-записях уменьшите значение TTL (Time To Live) для A-записи домена до минимального значения (например, 300 секунд). Это позволит быстрее обновить записи DNS и уменьшит время, в течение которого пользователи будут получать старый IP-адрес.
Обновление A-записи: После того как вы убедитесь, что новый сервер работает корректно, обновите A-запись в DNS, указав новый IP-адрес. Это делается в панели управления вашего регистратора доменных имен или хостинг-провайдера.
3. Тестирование
Проверка через файл hosts: Чтобы протестировать новый сервер до изменения DNS, вы можете внести запись в файл hosts на своем компьютере. Это позволит вам напрямую обращаться к новому IP-адресу без изменения публичных DNS-записей.
4. Мониторинг после миграции
Мониторинг трафика: После изменения A-записи следите за трафиком и производительностью сайта. Убедитесь, что все пользователи могут получить доступ к сайту без проблем.
5. Восстановление TTL
Восстановление TTL: После успешной миграции и проверки работы сайта верните значение TTL к исходным настройкам для оптимизации работы DNS.
Методы защиты от проблем при миграции
Использование CDN: Content Delivery Network (CDN) может помочь сгладить переход, так как она может кэшировать контент и направлять пользователей на ближайший доступный сервер.
301 редиректы: Если у вас изменяется структура URL или домен, настройте 301 редиректы с старых адресов на новые. Это поможет сохранить SEO-позиции и перенаправить пользователей.
Тестирование перед миграцией: Всегда проводите тестирование нового сервера перед изменением DNS-записей, чтобы убедиться в его работоспособности.
  </details>

91. Что такое socket?
<details>
<summary>Ответ</summary> 
Сокет — это программный интерфейс, который обеспечивает возможность обмена данными между различными приложениями через сеть. Он представляет собой комбинацию IP-адреса и номера порта, что позволяет идентифицировать конечную точку соединения в сети.
Основные аспекты сокетов
Определение:
Сокет можно рассматривать как виртуальную конструкцию, которая позволяет приложениям обмениваться данными. Он функционирует как "отверстие", через которое одно приложение может отправлять данные другому приложению, находящемуся на том же или другом компьютере в сети 12.
Типы сокетов:
Сетевые сокеты: Используются для коммуникации между компьютерами в сети. Они основаны на протоколах TCP/IP и позволяют приложениям обмениваться данными.
Unix-сокеты: Используются для взаимодействия между процессами на одном компьютере, обеспечивая более быструю передачу данных по сравнению с сетевыми сокетами 56.
Функциональность:
Сокеты позволяют программам устанавливать входящие и исходящие соединения, отправлять и получать данные. Это делает их неотъемлемой частью клиент-серверной архитектуры, где клиент запрашивает данные от сервера, а сервер отвечает на эти запросы 235.
Работа с сокетами:
Создание сокета обычно включает несколько шагов:
Создание сокета с помощью системного вызова.
Привязка (bind) сокета к локальному адресу и порту.
Прослушивание (listen) входящих соединений.
Принятие (accept) входящих соединений или установка соединения (connect) с удаленным сервером.
Отправка (send) и получение (receive) данных.
Закрытие (close) соединения после завершения обмена данными 6.
Применение сокетов
Сокеты широко используются в различных сетевых приложениях, таких как веб-серверы, почтовые клиенты и мессенджеры. Они позволяют разработчикам создавать эффективные механизмы для передачи данных между приложениями, что делает их важным инструментом в сетевом программировании 145.
  </details>

92. Как узнать, какие удаленные хосты подключаются к хосту через порт 8888? (с помощью команд и не используя /proc или /sys).
<details>
<summary>Ответ</summary> 
Чтобы узнать, какие удаленные хосты подключаются к вашему хосту через порт 8888, вы можете использовать несколько команд в Linux. Вот основные методы:
1. Использование netstat
Команда netstat позволяет просмотреть активные соединения и порты, которые находятся в состоянии прослушивания. Чтобы отфильтровать результаты по порту 8888, выполните следующую команду:
sudo netstat -anp | grep ':8888'
-a — показывает все соединения и прослушиваемые порты.
-n — выводит адреса и номера портов в числовом формате.
-p — показывает PID и имя процесса, который использует порт.
2. Использование ss
Команда ss является более современным инструментом для мониторинга сокетов и может использоваться аналогично netstat. Чтобы узнать, какие удаленные хосты подключаются к порту 8888, выполните:
sudo ss -tunap | grep ':8888'
-t — показывает только TCP-соединения.
-u — показывает только UDP-соединения.
-n — выводит адреса и номера портов в числовом формате.
-a — показывает все соединения.
-p — отображает PID и имя процесса.
3. Использование lsof
Команда lsof может быть использована для отображения открытых файлов и сетевых соединений. Чтобы найти процессы, использующие порт 8888, выполните:
sudo lsof -i :8888
  </details>

93. У нас есть несколько сетевых карт. Как увеличить пропускную способность сервера?
<details>
<summary>Ответ</summary> 

  </details>


94. Как проверить открытые порты на удаленном сервере без команд Netcat или Nmap Linux?
<details>
<summary>Ответ</summary> 
Для проверки открытых портов на удаленном сервере без использования команд netcat или nmap, можно воспользоваться следующими методами:
1. Использование Telnet
Команда telnet позволяет проверить доступность определенного порта на удаленном сервере. Синтаксис команды:
telnet [IP-адрес или доменное имя] [номер порта]
Если порт открыт, вы увидите сообщение о подключении. Если порт закрыт, вы получите сообщение об ошибке.
Пример:
telnet 192.168.1.10 8888
2. Использование Curl
Команда curl может быть использована для проверки доступности HTTP и других протоколов через определенные порты. Например:
curl -I http://[IP-адрес или доменное имя]:[номер порта]
Это отправит HTTP-запрос на указанный порт и покажет заголовки ответа.
Пример:
curl -I http://192.168.1.10:8888
Если порт открыт и служба отвечает, вы увидите заголовки ответа от сервера.
3. Использование OpenSSL
Если вы хотите проверить доступность порта для SSL-соединений (например, HTTPS), вы можете использовать openssl:
openssl s_client -connect [IP-адрес или доменное имя]:[номер порта]
Это установит SSL-соединение с указанным портом и покажет информацию о сертификате.
Пример:
openssl s_client -connect 192.168.1.10:8888
  </details>

95. Root-пароль неизвестен или потерян. Какова процедура восстановления?
<details>
<summary>Ответ</summary> 
Если вы забыли или потеряли root-пароль в Linux, существует несколько способов его восстановления. Вот основные шаги, которые вы можете предпринять для сброса пароля:
1. Использование GRUB для сброса пароля
Перезагрузите систему.
Откройте меню GRUB: При загрузке нажмите клавишу Shift или Esc, чтобы отобразить меню загрузчика GRUB.
Редактирование параметров загрузки:
Выберите нужный пункт загрузки и нажмите e для редактирования.
Найдите строку, начинающуюся с linux, и добавьте в конец строки параметр init=/bin/bash.
Загрузите систему: Нажмите F10 или Ctrl + X, чтобы загрузить систему с новыми параметрами.
Перемонтируйте файловую систему: После загрузки выполните команду:
mount -o remount,rw /
Сбросьте пароль: Введите команду для изменения пароля root:
passwd
Введите новый пароль и подтвердите его.
Перезагрузите систему:
exec /sbin/init
или просто перезагрузите с помощью:
reboot -f
2. Использование LiveCD
Если доступ к GRUB невозможен, вы можете использовать LiveCD:
Загрузитесь с LiveCD (или USB).
Откройте терминал и найдите корневой раздел:
fdisk -l
Смонтируйте корневой раздел (например, /dev/sda1):
mount /dev/sda1 /mnt
Используйте chroot:
chroot /mnt
Сбросьте пароль root:
passwd root
Выйдите из chroot и размонтируйте раздел:
exit
umount /mnt
Перезагрузите систему.
3. Использование режима восстановления (Recovery Mode)
Перезагрузите систему и выберите режим восстановления в меню GRUB.
Выберите опцию для перехода в командный интерпретатор (root shell).
Перемонтируйте файловую систему в режиме записи:
mount -o remount,rw /
Сбросьте пароль root:
passwd root
Перезагрузите систему.
  </details>

96. Как управлять правами на файловой системе в Linux?
<details>
<summary>Ответ</summary> 
Управление правами на файловой системе в Linux осуществляется с помощью нескольких ключевых команд и концепций. Основные команды для управления правами доступа включают chmod, chown
  </details>

97. Что такое Firewall?
<details>
<summary>Ответ</summary> 
Firewall (файервол, брандмауэр или межсетевой экран) — это система, предназначенная для защиты компьютерных сетей и устройств от несанкционированного доступа и вредоносного трафика. Он функционирует как фильтр между внутренней сетью и внешним миром, контролируя входящий и исходящий трафик на основе заданных правил безопасности.
Основные функции файервола:
Фильтрация трафика:
Firewall анализирует пакеты данных, проходящие через него, и принимает решения о том, разрешить или заблокировать их на основе заранее определённых правил. Это позволяет предотвратить доступ вредоносных программ и хакеров к системе13.
Мониторинг соединений:
Он регистрирует информацию о сетевом трафике, что помогает администраторам отслеживать подозрительную активность и предотвращать атаки7.
Контроль доступа:
Файервол может ограничивать доступ к определённым ресурсам, таким как веб-сайты или приложения, что часто используется в корпоративных сетях для соблюдения политики безопасности46.
Типы файерволов:
Программные файерволы: Устанавливаются на отдельные компьютеры и защищают их от внешних угроз. Примеры включают встроенные файерволы в операционные системы (например, Windows Firewall) или антивирусные программы с функцией брандмауэра25.
Аппаратные файерволы: Это отдельные устройства, которые устанавливаются на границе сети и защищают всю локальную сеть. Они предлагают более мощную защиту и могут обрабатывать больший объём трафика67.
  </details>

98. Чем отличается stateless от stateful фаерволов?
<details>
<summary>Ответ</summary> 
Stateful и stateless файерволы представляют собой два различных подхода к фильтрации сетевого трафика, и они имеют значительные различия в способах обработки и анализа данных.
Основные различия между stateful и stateless файерволами
Отслеживание состояния соединений:
Stateful файервол: Этот тип файервола отслеживает состояние активных соединений и сохраняет информацию о них в специальной таблице состояний. Это позволяет ему принимать решения о том, разрешить или заблокировать пакеты на основе контекста соединения, а не только на основе заголовков пакетов. Например, он может определить, является ли пакет частью уже установленного соединения.
Stateless файервол: В отличие от stateful, stateless файервол не сохраняет информацию о состоянии соединений. Он анализирует каждый пакет независимо, основываясь только на его заголовках (например, IP-адресах источника и назначения, номерах портов и протоколах). Это делает его менее гибким в распознавании сложных атак.
Глубина анализа:
Stateful файервол: Обеспечивает более глубокую проверку пакетов, включая анализ содержимого и поведения на уровне приложений (Layer 7). Это позволяет выявлять более сложные угрозы и атаки, такие как IP-спуфинг или атаки типа "отказ в обслуживании" (DoS).
Stateless файервол: Ограничивается поверхностным анализом, что делает его быстрее, но менее эффективным в борьбе с продвинутыми угрозами.
Производительность:
Stateful файервол: Обычно требует больше ресурсов для обработки и хранения информации о состоянии соединений. Это может привести к увеличению задержек при обработке трафика.
Stateless файервол: Более быстрый и менее требовательный к ресурсам, так как не нужно хранить состояние соединений. Это делает его подходящим для сценариев с высокой пропускной способностью.
Применение:
Stateful файерволы: Чаще используются в сложных сетевых средах, где требуется высокая степень безопасности и контроль за состоянием соединений.
Stateless файерволы: Подходят для простых сетевых конфигураций или для базовой фильтрации трафика, где производительность важнее глубины анализа.
  </details>

99. Сколько таблиц в iptables?
<details>
<summary>Ответ</summary> 
В iptables существует пять основных таблиц, каждая из которых предназначена для выполнения определенных функций:
filter: Это таблица по умолчанию, используемая для фильтрации пакетов. Она содержит три встроенные цепочки:
INPUT: Управляет входящими соединениями.
FORWARD: Управляет пакетами, которые проходят через систему.
OUTPUT: Управляет исходящими соединениями.
nat: Эта таблица используется для преобразования сетевых адресов (например, при пробросе портов). Она также содержит три цепочки:
PREROUTING: Применяется перед маршрутизацией пакета.
POSTROUTING: Применяется после маршрутизации пакета.
OUTPUT: Применяется к исходящим пакетам.
mangle: Используется для специальных изменений заголовков пакетов, таких как изменение параметров типа обслуживания (ToS) и времени жизни (TTL). Она содержит все пять цепочек.
raw: Эта таблица предназначена для настройки пакетов и позволяет отключить отслеживание состояний соединений.
security: Используется для взаимодействия с механизмами безопасности, такими как SELinux, и применяется в сетевых правилах мандатного управления доступом.
Таким образом, в iptables есть пять таблиц, каждая из которых выполняет свои уникальные функции в управлении сетевым трафиком 
  </details>

100. Можно ли настроить трансляцию NAT с помощью iptables? Какую таблицу следует использовать?
<details>
<summary>Ответ</summary> 
Да, вы можете настроить трансляцию NAT с помощью iptables. Для этого следует использовать таблицу nat, которая предназначена для управления преобразованием сетевых адресов.
  </details>

101. Какую таблицу используют для смены заголовков пакетов?
<details>
<summary>Ответ</summary> 
Для изменения заголовков пакетов в iptables используется таблица mangle. Эта таблица предназначена для модификации различных полей заголовков IP-пакетов, таких как TTL (Time to Live), TOS (Type of Service) и другие параметры.
  </details>

102. Если вам ломают Linux-сервер, то как более эффективно блокировать трафик с IP-адресов?
<details>
<summary>Ответ</summary> 
Чтобы эффективно блокировать трафик с определенных IP-адресов на Linux-сервере, можно использовать несколько методов. Основным инструментом для этой задачи является iptables, который позволяет управлять сетевым трафиком на уровне ядра.
Кроме iptables, вы можете использовать другие инструменты для управления доступом к серверу:
Fail2Ban: Это программа, которая отслеживает логи и автоматически блокирует IP-адреса, которые подозреваются в атаках (например, Brute Force).
UFW (Uncomplicated Firewall): Это более простой интерфейс для управления правилами iptables, который может быть удобен для пользователей, не знакомых с командной строкой.
  </details>

103. Принцип работы GCP Firewall: можем ли мы профильтровать трафик на Load Balancer?
<details>
<summary>Ответ</summary> 

  </details>

104. Можно ли полностью отключить SELinux на лету?
<details>
<summary>Ответ</summary> 
Да, вы можете временно отключить SELinux на лету, но это изменение не сохранится после перезагрузки системы. Для этого используется команда:
bash
sudo setenforce 0
Эта команда переводит SELinux в режим Permissive, что означает, что система будет регистрировать нарушения политики безопасности, но не будет их блокировать. Однако, чтобы полностью отключить SELinux (перевести в режим Disabled), необходимо внести изменения в конфигурационный файл и перезагрузить систему.
  </details>

105. С какими secrets management systems вы работали?
<details>
<summary>Ответ</summary> 
. HashiCorp Vault
Описание: Vault является мощным инструментом для управления секретами, который предоставляет API для хранения и получения секретов. Он поддерживает шифрование, управление доступом и автоматическую ротацию секретов.
Функции:
Генерация временных учетных данных для баз данных и других сервисов.
Поддержка различных методов аутентификации.
Возможность интеграции с облачными провайдерами.
  </details>


106. Что такое сервер NAT?
<details>
<summary>Ответ</summary> 
Сервер NAT (Network Address Translation) — это устройство или программное обеспечение, которое выполняет преобразование внутренних (приватных) IP-адресов во внешние (публичные) и наоборот. Эта технология позволяет устройствам в локальной сети взаимодействовать с внешним миром, используя один или несколько публичных IP-адресов.
  </details>

107. У нас есть сервер NAT, и мы хотим обеспечить доступ по IP к серверу снаружи. Как нам это реализовать?
<details>
<summary>Ответ</summary> 
Чтобы обеспечить доступ к серверу, находящемуся за NAT (Network Address Translation), вам нужно настроить перенаправление портов на маршрутизаторе или использовать другие методы, такие как VPN или SSH-туннели. Вот несколько подходов для реализации этого:
1. Перенаправление портов (Port Forwarding)
Это самый распространенный метод, который позволяет перенаправлять входящие соединения на определенный порт вашего маршрутизатора к внутреннему IP-адресу вашего сервера.
Шаги:
Настройте статический IP-адрес для сервера в локальной сети, чтобы его адрес не менялся.
Зайдите в настройки вашего маршрутизатора и найдите раздел, связанный с перенаправлением портов (Port Forwarding).
Добавьте правило, указывающее внешний порт (например, 2222) и внутренний IP-адрес вашего сервера с соответствующим портом (например, 22 для SSH).
Пример настройки:
Внешний порт: 2222
Внутренний IP: 192.168.1.100
Внутренний порт: 22
Теперь вы сможете подключаться к серверу по внешнему IP-адресу маршрутизатора и порту 2222.
2. Использование VPN
Если у вас есть доступ к VPN-серверу, вы можете создать защищенное соединение между вашим клиентом и сервером за NAT.
Шаги:
Настройте VPN-сервер на одном из ваших устройств с публичным IP.
Подключите сервер за NAT к этому VPN.
Теперь вы сможете получить доступ к серверу через VPN-клиент.
3. SSH-туннелирование
Если у вас есть доступ к другому серверу с публичным IP, вы можете использовать SSH-туннелирование для доступа к вашему серверу за NAT.
Шаги:
На сервере с публичным IP выполните команду для создания обратного SSH-туннеля:
ssh -R [публичный_порт]:localhost:[порт_сервера] user@public_ip
Например:
ssh -R 2222:localhost:22 user@public_ip
Теперь вы можете подключиться к вашему серверу за NAT через публичный IP и указанный порт:
ssh user@public_ip -p 2222
  </details>


